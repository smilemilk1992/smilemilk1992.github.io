{"meta":{"title":"smilemilk","subtitle":"大数据 · Python · 技术博客","description":"good good learn, day day up!","author":"Chen Hao","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-11-24T07:44:33.000Z","updated":"2017-11-28T11:28:18.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-11-27T15:29:11.000Z","updated":"2017-11-27T15:43:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-27T15:01:30.000Z","updated":"2017-11-27T15:42:10.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java分布式锁之redis精简篇","slug":"java分布式锁之redis精简篇","date":"2019-03-28T06:02:31.000Z","updated":"2019-03-28T06:44:42.314Z","comments":true,"path":"2019/03/28/java分布式锁之redis精简篇/","link":"","permalink":"http://yoursite.com/2019/03/28/java分布式锁之redis精简篇/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp; 分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。前面已经介绍了redis的分布式锁的实现，但是本章介绍另外一种基于redis分布式锁的实现。 1、可靠性首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： 互斥性。在任意时刻，只有一个客户端能持有锁。 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 2、代码实现 组件依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 加锁 &amp; 释放锁代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RedisTool &#123; private static final Long RELEASE_SUCCESS = 1L; private static final String LOCK_SUCCESS = \"OK\"; private static final String SET_IF_NOT_EXIST = \"NX\"; private static final String SET_WITH_EXPIRE_TIME = \"PX\"; /** * 尝试获取分布式锁 * * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @param expireTime 超期时间 * @return 是否获取成功 * **/ public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; return false; &#125; /** * 释放分布式锁 * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @return 是否释放成功 */ public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123; String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; return false; &#125;&#125; 加锁说明 &ensp;&ensp;&ensp;&ensp;可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参： 第一个为key，我们使用key来当锁，因为key是唯一的。 第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。 第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作； 第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。 第五个为time，与第四个参数相呼应，代表key的过期时间。 总的来说，执行上面的set()方法就只会导致两种结果： 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。 已有锁存在，不做任何操作。 &ensp;&ensp;&ensp;&ensp;我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。 解锁说明 &ensp;&ensp;&ensp;&ensp;我们写了一个简单的Lua脚本代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。 &ensp;&ensp;&ensp;&ensp;Lua代码的功能是首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁），确保上述操作是原子性的。 详细实现代码参见 github","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java锁之RateLimiter（限制访问速率）","slug":"java锁之RateLimiter（限制1s内的访问速率）","date":"2019-03-27T08:16:00.000Z","updated":"2019-03-27T09:45:59.929Z","comments":true,"path":"2019/03/27/java锁之RateLimiter（限制1s内的访问速率）/","link":"","permalink":"http://yoursite.com/2019/03/27/java锁之RateLimiter（限制1s内的访问速率）/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;在日常生活中，我们肯定收到过不少不少这样的短信，“京东最新优惠卷…”，“天猫送您…”。这种类型的短信是属于推广性质的短信。这种短信一般群发量会到千万级别。然而，要完成这些短信发送，我们是需要调用服务商的接口来完成的。倘若一次发送的量在200万条，而我们的服务商接口每秒能处理的短信发送量有限，只能达到200条每秒。那么这个时候就会产生问题了，我们如何能控制好程序发送短信时的速度昵？于是限流器就得用上了。 &ensp;&ensp;&ensp;&ensp;RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率。与Semaphore 相比，Semaphore 限制了并发访问的数量而不是使用速率。通过设置许可证的速率来定义RateLimiter。在默认配置下，许可证会在固定的速率下被分配，速率单位是每秒多少个许可证。为了确保维护配置的速率，许可会被平稳地分配，许可之间的延迟会做调整。可能存在配置一个拥有预热期的RateLimiter 的情况，在这段时间内，每秒分配的许可数会稳定地增长直到达到稳定的速率。 &ensp;&ensp;&ensp;&ensp;RateLimiter是guava提供的基于令牌桶算法的实现类，可以非常简单的完成限流特技，并且根据系统的实际情况来调整生成token的速率。通常可应用于抢购限流防止冲垮系统；限制某接口、服务单位时间内的访问量，譬如一些第三方服务会对用户访问量进行限制；限制网速，单位时间内只允许上传下载多少字节等。 1、引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;25.1-jre&lt;/version&gt;&lt;/dependency&gt; 2、代码实战一 每秒限制运行3个线程 1234567891011121314151617181920public class RateLimiterTest &#123; public static void main(String[] args) throws InterruptedException &#123; //新建一个每秒限制3个的令牌桶 RateLimiter rateLimiter = RateLimiter.create(3.0); ExecutorService executor = Executors.newFixedThreadPool(100); for (int i = 0; i &lt; 10; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; //获取令牌桶中一个令牌，最多等待10秒 if (rateLimiter.tryAcquire(1, 10, TimeUnit.SECONDS)) &#123; System.out.println(Thread.currentThread().getName()+\" \"+new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125; &#125; &#125;); &#125; executor.shutdown(); &#125;&#125; 运行结果： 12345678910pool-1-thread-1 2019-03-27 16:47:52pool-1-thread-10 2019-03-27 16:47:53pool-1-thread-9 2019-03-27 16:47:53pool-1-thread-8 2019-03-27 16:47:53pool-1-thread-7 2019-03-27 16:47:54pool-1-thread-6 2019-03-27 16:47:54pool-1-thread-5 2019-03-27 16:47:54pool-1-thread-4 2019-03-27 16:47:55pool-1-thread-3 2019-03-27 16:47:55pool-1-thread-2 2019-03-27 16:47:55 注：public boolean tryAcquire(long timeout,TimeUnit unit) 从RateLimiter获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待）。该方法等同于tryAcquire(1, timeout, unit)。 参数: timeout – 等待许可的最大时间，负数以0处理 unit – 参数timeout 的时间单位 返回： true表示获取到许可，反之则是false 3、实战代码二 12345678910111213141516171819202122public class RateLimiterTest &#123; public static void main(String[] args) throws InterruptedException &#123; //每1s产生0.5个令牌，也就是说该接口2s只允许调用1次 RateLimiter rateLimiter = RateLimiter.create(0.5,1,TimeUnit.SECONDS); ExecutorService executor = Executors.newFixedThreadPool(100); for (int i = 0; i &lt; 10; i++) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; //获取令牌桶中一个令牌，最多等待10秒 if (rateLimiter.tryAcquire(1, 10, TimeUnit.SECONDS)) &#123; System.out.println(Thread.currentThread().getName()+\" \"+new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); &#125;else &#123; System.out.println(\"请求频繁\"); &#125; &#125; &#125;); &#125; executor.shutdown(); &#125;&#125; 请求结果：12345678910请求频繁请求频繁请求频繁请求频繁请求频繁pool-1-thread-1 2019-03-27 17:18:01pool-1-thread-10 2019-03-27 17:18:03pool-1-thread-2 2019-03-27 17:18:05pool-1-thread-9 2019-03-27 17:18:07pool-1-thread-8 2019-03-27 17:18:09 &ensp;&ensp;&ensp;&ensp;从上面结果可以看出，接口限制为每2秒请求一次，那么同时来10个线程，需要20s全部处理完，但是rateLimiter.tryAcquire限制了10s内没有获取到令牌就抛出异常，所以结果中会有5个是请求频繁的。 4、方法摘要 修饰符和类型 方法描述 double acquire() 从RateLimiter获取一个许可，该方法会被阻塞直到获取到请求 double acquire(int permits) 从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求 static create(double permitsPerSecond) 根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询） static create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) 根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数会平稳地增长直到预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和） double getRate() 返回RateLimiter 配置中的稳定速率，该速率单位是每秒多少许可数 void setRate(double permitsPerSecond) 更新RateLimite的稳定速率，参数permitsPerSecond 由构造RateLimiter的工厂方法提供。 String toString() 返回对象的字符表现形式 boolean tryAcquire() 从RateLimiter 获取许可，如果该许可可以在无延迟下的情况下立即获取得到的话 boolean tryAcquire(int permits) 从RateLimiter 获取许可数，如果该许可数可以在无延迟下的情况下立即获取得到的话 boolean tryAcquire(int permits, long timeout, TimeUnit unit) 从RateLimiter 获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可数的话，那么立即返回false （无需等待） boolean tryAcquire(long timeout, TimeUnit unit) 从RateLimiter 获取许可如果该许可可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout 过期之前获取得到许可的话，那么立即返回false（无需等待）","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java锁之Semaphore（信号量，限制并发数量）","slug":"java锁之Semaphore（信号量，限制并发数量）","date":"2019-03-27T07:07:20.000Z","updated":"2019-03-27T08:25:29.819Z","comments":true,"path":"2019/03/27/java锁之Semaphore（信号量，限制并发数量）/","link":"","permalink":"http://yoursite.com/2019/03/27/java锁之Semaphore（信号量，限制并发数量）/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;由于接口最近经常性的有大量的请求打进来，为了防止接口挂掉，这里引入了限速，本章主要介绍Semaphore &ensp;&ensp;&ensp;&ensp;Semaphore(信号量)使用来控制通知访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 &ensp;&ensp;&ensp;&ensp;我们可以这么理解Semaphore，比如一个厕所只有6个坑，同时只能满足6个人上厕所(变态除外)，其他人想蹲坑，只能排队等待，如果有人从厕所出来，后面的一个人就可以进去。在这个例子中人就是线程，蹲坑表示线程在执行，离开表示线程执行完毕，而坑的数量就表示Semaphore的个数。 官方的解释为: Semaphore是一个计数信号量 从概念上将,Semaphore包含一组许可证 如果有需要的话,每次调用acquire()方法都会阻塞,直到获取一个可用的许可证 每次调用release()方法都会释放持有许可证的线程,并且归还Semaphore一个可用的许可证 实际上并没有真实的许可证对象供线程使用, Semaphore只是对可用的数量进行管理维护 1、应用场景&ensp;&ensp;&ensp;&ensp;Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。 1234567891011121314151617181920212223242526public class SemaphoreTest &#123; private static final int THREAD_COUNT = 40; private static ExecutorService threadPool = Executors .newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10,true); public static void main(String[] args)&#123; for(int i=0;i&lt;THREAD_COUNT;i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println(\"线程\" + Thread.currentThread().getName() +\" 读取文件\"); s.acquire(); System.out.println(\"线程\" + Thread.currentThread().getName() +\" 存储文件\"); Thread.sleep(5000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; s.release(); &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; &ensp;&ensp;&ensp;&ensp;上述代码创建了40个线程，但是只能允许有10个线程并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。 2、Semaphore常用函数非公平 public Semaphore(int permits);//permits就是允许同时运行的线程数目 公平 public Semaphore(int permits,boolean fair);//permits就是允许同时运行的线程数目,fair=true代表公平 创建一个信号量 Semaphore semaphore = new Semaphore(int permits); 从信号量中获取一个许可 semaphore.acquire(); 释放一个许可(在释放许可之前，必须先获获得许可。) semaphore.release(); 尝试获取一个许可，若获取成功返回true，若获取失败返回false semaphore.tryAcquire(); 所有函数： 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建具有给定的许可数和非公平的公平设置的 Semaphore。Semaphore(int permits)// 创建具有给定的许可数和给定的公平设置的 Semaphore。Semaphore(int permits, boolean fair)// 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。void acquire()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。void acquire(int permits)// 从此信号量中获取许可，在有可用的许可前将其阻塞。void acquireUninterruptibly()// 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。void acquireUninterruptibly(int permits)// 返回此信号量中当前可用的许可数。int availablePermits()// 获取并返回立即可用的所有许可。int drainPermits()// 返回一个 collection，包含可能等待获取的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正在等待获取的线程的估计数目。int getQueueLength()// 查询是否有线程正在等待获取。boolean hasQueuedThreads()// 如果此信号量的公平设置为 true，则返回 true。boolean isFair()// 根据指定的缩减量减小可用许可的数目。protected void reducePermits(int reduction)// 释放一个许可，将其返回给信号量。void release()// 释放给定数目的许可，将其返回到信号量。void release(int permits)// 返回标识此信号量的字符串，以及信号量的状态。String toString()// 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。boolean tryAcquire()// 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。boolean tryAcquire(int permits)// 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。boolean tryAcquire(int permits, long timeout, TimeUnit unit)// 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。boolean tryAcquire(long timeout, TimeUnit unit) 3、代码实例假设有10个人在银行办理业务，只有2个工作窗口，代码实现逻辑如下123456789101112131415161718192021222324252627282930313233public class SemaphoreDemo &#123; // 排队总人数（请求总数） public static int clientTotal = 10; // 可同时受理业务的窗口数量（同时并发执行的线程数） public static int threadTotal = 2; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal; i++) &#123; final int count = i; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(1); resolve(count); semaphore.release(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); &#125; private static void resolve(int i) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()+\" 服务号&#123;&#125;，受理业务中。。。\"+i); Thread.sleep(2000); &#125;&#125; 输出结果：12345678910pool-1-thread-2 服务号&#123;&#125;，受理业务中。。。1 1553673884015pool-1-thread-1 服务号&#123;&#125;，受理业务中。。。0 1553673884015pool-1-thread-3 服务号&#123;&#125;，受理业务中。。。2 1553673886016pool-1-thread-4 服务号&#123;&#125;，受理业务中。。。3 1553673886016pool-1-thread-5 服务号&#123;&#125;，受理业务中。。。4 1553673888018pool-1-thread-6 服务号&#123;&#125;，受理业务中。。。5 1553673888018pool-1-thread-7 服务号&#123;&#125;，受理业务中。。。6 1553673890020pool-1-thread-8 服务号&#123;&#125;，受理业务中。。。7 1553673890020pool-1-thread-9 服务号&#123;&#125;，受理业务中。。。8 1553673892020pool-1-thread-10 服务号&#123;&#125;，受理业务中。。。9 1553673892020 从输出结果看，每隔两秒，有两个线程被执行！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java日志-log4j的使用","slug":"java日志-log4j的使用","date":"2019-02-25T06:24:35.000Z","updated":"2019-02-25T11:13:04.463Z","comments":true,"path":"2019/02/25/java日志-log4j的使用/","link":"","permalink":"http://yoursite.com/2019/02/25/java日志-log4j的使用/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;日志是应用软件中不可缺少的部分，Apache的开源项目log4j是一个功能强大的日志组件,提供方便的日志记录。在apache网站：jakarta.apache.org/log4j 可以免费下载到Log4j最新版本的软件包 1 log4j的优点&ensp;&ensp;&ensp;&ensp;log4j是Apache的一个开源代码项目, 通过使用log4j; 我们可以控制日志信息输送的目的地是控制台/文件/GUI组件/甚至是套接口服务器/NT的时间记录器/UNIX Syslog 守护进程等, 我们也可以控制每一条日志的输出格式; 通过定义每一条日志信息的级别, 我们能够更加细致的控制日志的生成过程, 最令人感兴趣的就是, 这些可以通过一个配置文件来灵活进行配置, 而不是需要修改应用的代码 &ensp;&ensp;&ensp;&ensp;在应用程序中添加日志记录总的来说基于三个目的: ① 见识代码中变量的变化, 周期性的记录到文件中供其他应用进行统计分析工作; ② 跟踪代码运行时轨迹, 作为日后审计的依据; ③ 担当集成开发环境中的调试器的作用, 向文件或控制台打印代码的调试信息 2 log4j配置文件&ensp;&ensp;&ensp;&ensp;Log4j由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低有FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。 &ensp;&ensp;&ensp;&ensp;其log4j.properties的详细配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#通过根日志记录器指定日志级别及输出源 #日志输出的优先级： debug &lt; info &lt; warn &lt; error &lt; fatal#定义根日志记录器的日志级别(info)及输出源的别名(console,myFile)#该定义让日志在控制台和文件输出，并且只输出info级别以上的日志log4j.rootLogger=info,console,myFile#######配置输出源console的具体实现为控制台输出########定义输出源别名console（即根日志记录器定义的输出源）#的实现类是ConsoleAppender（控制台输出源）log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out#指定日志输出格式的格式转换器为PatternLayout实现类log4j.appender.console.layout=org.apache.log4j.PatternLayout#定义日志输出的具体格式log4j.appender.console.layout.ConversionPattern=[QC] %d %p [%t] %C.%M(%L) | %m%n#######配置输出源myFile的具体实现为文件输出########定义输出源别名myFile（即根日志记录器定义的输出源）#的实现类是DailyRollingFileAppender（文件输出源,按照天输出）log4j.appender.myFile=org.apache.log4j.DailyRollingFileAppender#定义日志文件的存储路径log4j.appender.myFile.File=src/log/logProperties/log4j.log#定义文件生成的日期后缀（按照天输出）log4j.appender.myFile.DatePattern='.'yyyy-MM-dd#指定日志输出格式的格式转换器为PatternLayout实现类log4j.appender.myFile.layout=org.apache.log4j.PatternLayout#定义日志输出的具体格式log4j.appender.myFile.layout.ConversionPattern=[QC] %d %p [%t] %C.%M(%L) | %m%n#设置输出日志文件编码（可以控制乱码情况）log4j.appender.myFile.encoding=UTF-8 #xxx：表示要屏蔽的类,=后面 表示这个类下的日志只打印error级别的log4j.logger.com.alibaba.dubbo=errorlog4j.logger.com.org.springframework=errorlog4j.logger.org.springframework=errorlog4j.logger.org.mybatis=errorlog4j.logger.com.alibaba.druid=errorlog4j.logger.org.apache.zookeeper=info #######输出格式解释########%d: 日志打印的时间点，默认格式为ISO8601，也可以另外指定格式， #定义如下： %d&#123;yyy年MM月dd日 HH时mm分ss秒SSS&#125;，则会输出： #2018年01月06日 14时47分45秒590#%p: 输出日志级别，即DEBUG，INFO，WARN，ERROR，FATAL #%-5p：表示字符小于5位，则字符居左（不加“-”号则字符居右），你可以举一反三#%c: 日志所在类的全名#%M: 日志所在方法的名字#%m: 日志信息#%n: 输出一个回车换行符#%L: 输出代码中的行号 &ensp;&ensp;&ensp;&ensp;也可以配置在xml文件，其log4j.xml的详细配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;log4j:configuration&gt; &lt;appender name=\"LOGFILE\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;!--$&#123;logPath&#125;/weibo-crawl-info.log--&gt; &lt;param name=\"File\" value=\"LogTest-info.log\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[QC] %d %p [%t] %C.%M(%L) | %m%n\" /&gt; &lt;/layout&gt; &lt;filter class=\"org.apache.log4j.varia.LevelRangeFilter\"&gt; &lt;param name=\"LevelMin\" value=\"INFO\" /&gt; &lt;param name=\"LevelMax\" value=\"INFO\" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name=\"LOGFILE-ERROR\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"LogTest-error.log\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[QC] %d %p [%t] %C.%M(%L) | %m%n\" /&gt; &lt;/layout&gt; &lt;filter class=\"org.apache.log4j.varia.LevelRangeFilter\"&gt; &lt;param name=\"LevelMin\" value=\"WARN\" /&gt; &lt;param name=\"LevelMax\" value=\"ERROR\" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Threshold\" value=\"INFO\"/&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"[QC] %d %p [%t] %C.%M(%L) | %m%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 针对个别包日志可以进行单独的设置级别，用于过滤 --&gt; &lt;!-- &lt;logger name=\"com.sohu.mrd.service.DocIDService.NewsetNewDocIdNews\"&gt; &lt;level value=\"OFF\" /&gt; &lt;level value=\"WARN\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;appender-ref ref=\"LOGFILE\" /&gt; &lt;/logger&gt; --&gt; &lt;root&gt; &lt;level value=\"INFO\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;appender-ref ref=\"LOGFILE\" /&gt; &lt;appender-ref ref=\"LOGFILE-ERROR\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 3 调用日志配置结果信息依赖jar包：1234567891011&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 测试类： 1234567public class LogTest &#123; private static final Logger log = Logger.getLogger(LogTest.class); public static void main(String[] args)&#123; log.info(\"信息\"); log.error(\"错误\"); &#125;&#125; 结果： 12[QC] 2019-02-25 15:38:53,700 INFO [main] com.Log.LogTest.main(13) | 信息[QC] 2019-02-25 15:38:53,703 ERROR [main] com.Log.LogTest.main(15) | 错误 &ensp;&ensp;&ensp;&ensp;前面已经介绍了logback的使用，目前我本人也基本上用logback，用起来确实比log4j好使，请大家根据自己的喜好来使用吧！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java日志-logback的入门使用","slug":"java日志-logback的使用","date":"2019-02-20T06:23:44.000Z","updated":"2019-02-20T12:24:36.976Z","comments":true,"path":"2019/02/20/java日志-logback的使用/","link":"","permalink":"http://yoursite.com/2019/02/20/java日志-logback的使用/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;本文旨在如何快速在maven项目中配置logback日志框架，使日志即输出在控制台，又以log文件的形式输出到本地磁盘保存。 1、logback的介绍Logback是由log4j创始人设计的另一个开源日志组件。它当前分为下面下个模块： logback-core：其它两个模块的基础模块 logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能 2、logback优点logback日志框架的优点： （1）内核重写，测试充分，初始化内存加载更小； （2）logback非常自然地直接实现了slf4j； （3）有比较齐全地200多页地文档； （4）配置修改后，支持自定重新加载配置文件； （5）支持自动去历史的日志文件。 3、logback配置 第一步：在pom.xml中引入对logback的依赖 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 第二步：配置logback.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"30 seconds\"&gt; &lt;!-- stdout start 所有信息输出到控制台 --&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; [line:%line] - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- stdout end --&gt; &lt;appender name=\"time-rolling\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;File&gt;$&#123;logPath&#125;/server.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;$&#123;logPath&#125;/server.%d&#123;yyyy-MM-dd&#125;&lt;/FileNamePattern&gt; &lt;maxHistory&gt;5&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; [line:%line] - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt;&lt;!-- 只打印INFO日志 --&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name=\"error-rolling\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;File&gt;$&#123;logPath&#125;/server.error&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;$&#123;logPath&#125;/server.error.%d&#123;yyyy-MM-dd&#125;&lt;/FileNamePattern&gt; &lt;maxHistory&gt;5&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;0&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt;&lt;!-- 只打印错误日志 --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name=\"log-trace-rolling\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;Encoding&gt;UTF-8&lt;/Encoding&gt; &lt;File&gt;$&#123;logPath&#125;/log_trace.log&lt;/File&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;FileNamePattern&gt;$&#123;logPath&#125;/log_trace.log.%d&#123;yyyy-MM-dd-HH&#125;&lt;/FileNamePattern&gt; &lt;maxHistory&gt;24&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 针对个别包日志可以进行单独的设置级别，用于过滤 --&gt; &lt;logger name=\"log-trace\" additivity=\"false\" level=\"INFO\"&gt; &lt;appender-ref ref=\"log-trace-rolling\"/&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.zookeeper.ZooKeeper\" additivity=\"false\" level=\"ERROR\"&gt; &lt;appender-ref ref=\"time-rolling\"/&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.zookeeper.ClientCnxn\" additivity=\"false\" level=\"ERROR\"&gt; &lt;appender-ref ref=\"time-rolling\"/&gt; &lt;/logger&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"time-rolling\"/&gt; &lt;appender-ref ref=\"error-rolling\"/&gt; &lt;appender-ref ref=\"stdout\"/&gt; &lt;/root&gt;&lt;/configuration&gt; ConsoleAppender：作用是将日志输出到控制台；RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件； 4、测试&ensp;&ensp;&ensp;&ensp;在完成上述配置后，我们来进行测试，看看是不是输出我们想要的日志文件。 123456public class test &#123; private static final org.slf4j.Logger logger = LoggerFactory.getLogger(HttpClientUtil.class); public static void main(String[] args) &#123; logger.info(\"logback test 成功\"); &#125;&#125; 大功告成！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"logback","slug":"logback","permalink":"http://yoursite.com/tags/logback/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"回首2018，展望2019","slug":"thksFor2018","date":"2019-02-16T00:08:08.000Z","updated":"2019-03-28T06:48:16.563Z","comments":true,"path":"2019/02/16/thksFor2018/","link":"","permalink":"http://yoursite.com/2019/02/16/thksFor2018/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;回首2018，一句话总结自己：成就不算少，进步不算多。 回首20182018年是一个丰收的一年，这一年的轨迹如下： （1）2018收到知乎 &amp; 搜狐的校招offer （2）顺利地完成了毕业论文和毕业答辩 （3）4月入职搜狐，从当初的项目啥也不懂到现在的业务清晰 （4）2018年9月接到第一个大的私活（因为初入职场，本不想接，怕完成不了，最后还是接了，因为我对自己爬虫技术还是相当有信心的） （5）迎娶白富美（瑶姐）~(ノへ￣、)捂脸 &ensp;&ensp;&ensp;&ensp;还有一些就不一一列举了，和一些大佬比起来，真的是小巫见大巫，不过对我本人来说真的是很有成就感了，接下来列举比较重要和难忘的几个事情。 知乎实习之旅 一、面试篇 &ensp;&ensp;&ensp;&ensp;我2017年9月初去的知乎面试，当时是地图导航过去的，对知乎的认知也仅仅局限于“知识社区”，我记得当时地图把我导到一个大的四合院里面，我当时就很纳闷，公司还可以在四合院的，与想象中的有点差距，接着我联系到了HR，我依然记得当时的一面面试官（电轻老师），长得真的很像李晨，问的问题我基本上都能回答的上，面试官话不多，比较害羞（程序员好像都这样吧哈哈），紧接着我被安排二面，二面的就是我当时的老大（雨舟老师），言语非常犀利，问的问题特别多，我记得有一个业务场景题，要求现场手写代码实现，我这个题足足想了20分钟，最后才做对一半，但是老大安慰我说：“嗯可以，思路还行，就是少考虑了一方面”，接着就问我啥时候可以到岗，我说任何时候，老大点了点头离开了。我当时以为没戏了等了半天HR还没来谈最后的offer，我当时觉得没戏了就直接回去了，等到快到地铁的时候，接到了老大打来的电话：“你人呢，咋面试完就跑啦，快回来，HR和你谈一下薪资”，我当时激动的语无伦次呀，于是骑着摩拜一路狂奔到公司，HR正好在公司门口等我，接着开始了我最喜欢的谈话，就是谈薪酬。 HR：面试官反馈你的业务水平还不错，被录取了。 我：哦哦（很淡定，其实内心已经飘了） HR：你在上一家公司实习工资多少？ 我：一天250（注：一个月下来5000多一点点，不包吃） HR：那这样我们给你一个月6000，配mac，公司包早中晚三餐 我：好 （内心欣喜若狂，但是后来我觉得我应该谈多一点的，太保守了，哎！） &ensp;&ensp;&ensp;&ensp;哎在回家的路上我即欣喜又后悔，我后悔谈少了，别人家HR那么爽快，我应该多说一点的，但是作为实习生来讲确实觉得6000+mac标配+三餐很诱人。 二、入职篇 &ensp;&ensp;&ensp;&ensp;我记得是9月13入职知乎，被HR安排到工位后，老大开始带着我一个个相互认识，介绍完后，我开始折腾公司给 配备的mac电脑，说实话之前一直用的windows系统的电脑，mac还真的玩不转，折腾半天最后问了老大这个系统咋用（当时真的很尴尬，就不说了），好在老大耐心教我怎么用这个系统。&ensp;&ensp;&ensp;&ensp;系统环境各方面安装好后，老大开始给我布置接下来的任务，让我写一个技术实现文档，第二天做一个技术报告评审，我想着这简单，于是就做了一些准备，第二天的技术评审是我第一次以实习生的身份在众多大佬面前做的报告，刚开始有点紧张到后面就适应了，主要是技术实现方案的讲述，后面组里的前辈也给一些改进方案，就这样第一次报告会圆满结束。 三、知乎实习感悟篇 &ensp;&ensp;&ensp;&ensp;我这边做的一个项目就是竞品分析，涉及到文本排重（当时选用的simhash来做），这里不做过多介绍，项目保密嘿嘿！此处省略1000字。在实习的过程当中，遇到了一些良师，比如雨舟老师、电轻老师、小崔老师、超强老师、志兴哥等。 &ensp;&ensp;&ensp;&ensp;雨舟老师，我们组老大，91年，人非常幽默，我总感觉和王祖蓝真的一模一样，不过91年能当老大，我真的很佩服，啥都懂，情商、智商双高，总是带我们讲段子，动不动就发车，猝不及防。 &ensp;&ensp;&ensp;&ensp;电轻老师，知乎元老级人物，创始人之一，是我当时的同桌，人比较内向，不喜欢讲话，但是技术，人没的说，很照顾我，给了我很多技术方面的支持。 &ensp;&ensp;&ensp;&ensp;小崔老师，知乎三年元老级人物，研究生毕业就待在知乎，可谓是看着知乎逐渐壮大，人特别幽默，有违和感，也带过我。 &ensp;&ensp;&ensp;&ensp;至兴哥，知乎元老级人物，对待技术非常认真负责，乐于助人，时常与我交流，同时给出一些针对性的指导意见。 &ensp;&ensp;&ensp;&ensp;以上带过我的老师就介绍这么多吧，真的很感恩遇见，我记得当时我像雨舟老师提出离职的时候，他竭力劝我留下来，真的很感恩，当时我一心想去搜狐（主要是搜狐的工资给到位了），哎想想自己当时太现实了，面向工资编程。电轻老师也拉着我到操场谈心，说实话我真的很感动，他说没有好好带我，本来刚开始想带我一起做一个项目，但是最后因为一些事情吧就没有实施，我当时那个感动，晚上电轻老师开车把我送到家，果然电轻老师是土豪，哈哈开着捷豹上下班，一路上我们聊了很多，，，真的感恩相遇。 读研感悟篇 &ensp;&ensp;&ensp;&ensp;18年5月18日是研究生毕业答辩的日子，依稀记得我的论文从最初的论文目录选定到最终论文定稿都是在马老师严格要求下完成。我的导师马老师是一位认真负责的老师，在毕业设计的整个过程中，从论文题目的选取、论文的开题、论文提纲的设计以及最终的撰写的过程中，马老师都给予了我细心的指导以及无私的帮助，并且给出的针对性的建议，整个论文才得以顺利完成。 &ensp;&ensp;&ensp;&ensp;时光飞逝，三年时光转瞬即逝，恍如昨日。还记得2015年我考上研究生的那份喜悦，到现如今踏上社会的忐忑，其实三年的时间不长也不短，短暂的三年有太多值得珍藏的回忆，在这里收获了满满的友情以及师生之情，正是有了你们的关心和支持，纵使前方道路充满坎坷，我也无所畏惧，勇往直前。 迎娶白富美&ensp;&ensp;&ensp;&ensp;2019年2月2号那天我迎娶了这个世界上最美丽的妻子，从此我将要为了我们幸福生活而努力！奋斗在北京，只为以后能够生活的更好。 展望20192019年注定是不平凡的一年，不忘初心，保持自我，脚踏实地，2019年我也给自己定了几个小目标： 2019年脚踏实地，努力提升自己的技术 2019年结交一些的志同道合的朋友 2019年坚持写博客 2019年努力挣钱买套房 …….","categories":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}],"tags":[],"keywords":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}]},{"title":"Ubuntu server下搭建Maven私服Nexus","slug":"Ubuntu-server下搭建Maven私服Nexus","date":"2019-02-14T14:22:19.000Z","updated":"2019-02-15T02:36:02.053Z","comments":true,"path":"2019/02/14/Ubuntu-server下搭建Maven私服Nexus/","link":"","permalink":"http://yoursite.com/2019/02/14/Ubuntu-server下搭建Maven私服Nexus/","excerpt":"","text":"Ubuntu系统上，用nexus搭建maven私服 1.下载Nexus wget -c http://download.sonatype.com/nexus/oss/nexus-2.10.0-02-bundle.tar.gz 2.启动Nexus tar -zxvf nexus-2.10.0-02-bundle.tar.gz cd /home/ubuntu/nexus/nexus-2.10.0-02/bin ./nexus start 启动成功，访问地址：http://ip:8081/nexus 3.配置nexus &ensp;&ensp;&ensp;&ensp;登录nexus，右上角Log In，默认登录用户名密码：admin/admin123 关于仓库的类型介绍 hosted 类型的仓库，内部项目的发布仓库 releases 内部的模块中release模块的发布仓库 snapshots 发布内部的SNAPSHOT模块的仓库 3rd party 第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去 proxy 类型的仓库，从远程中央仓库中寻找数据的仓库 group 类型的仓库，组仓库用来方便我们开发人员进行设置的仓库 &ensp;&ensp;&ensp;&ensp;分别将Apache Snapshots、Central、Codehaus Sanpshots下Download Remote Indexes选项选择【true】，保存即可，默认是false，如下图 &ensp;&ensp;&ensp;&ensp;然后分别将Apache Snapshots、Central、Codehaus Sanpshots更新Index，在每一个库上面右键操作Repair Index &ensp;&ensp;&ensp;&ensp;最后将Releases和Snapshots的Deployment Policy设置为Allow Redeploy 然后接可以测试maven仓库了。 4.配置 通常我们是修改本地的maven安装目录下的配置文件setting.xml，将本地仓库更换成私服仓库地址，保证本客户端上所有的项目都将使用私服，配置setting.xml如下：在加入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;Central&lt;/id&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/central/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;3rd party&lt;/id&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/thirdparty&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;dp-nexus-snapshots&lt;/id&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/snapshots&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;mvn-repo&lt;/id&gt; &lt;url&gt;http://maven.ansj.org/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--插件本地仓库--&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;&lt;/profiles&gt; 并在之后中加入激活 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; ** 注：dev和上面id保持同步 如果 构建的项目需发布项目到私有库，在setting.xml配置发布的账户 12345678910111213&lt;servers&gt; &lt;server&gt; &lt;id&gt;mrd-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;mrd-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 在项目中，则需要项目的pom.xml文件中添加如下，项目中id需和server中id一致： 12345678910111213&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;mrd-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt; http://ip:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;!-- use the following if you ARE using a snapshot version. --&gt; &lt;snapshotRepository&gt; &lt;id&gt;mrd-snapshots&lt;/id&gt; &lt;name&gt;Search Book Replace Plugin&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 镜像配置 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;mirrorOf&gt;nexus&lt;/mirrorOf&gt; &lt;name&gt;linux-nexus&lt;/name&gt; &lt;url&gt;http://ip:8081/nexus/content/groups/public&lt;/url&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 然后执行maven clean deploy，检测是否发布成功～在私服上，通过左边的Artifact Search 搜索窗口，查看jar包是否在私服下。 也可以通过地址：http://ip:8081/nexus/content/repositories/releases 查询是否上传成功 12345&lt;dependency&gt; &lt;groupId&gt;com.sohu.NettyTest&lt;/groupId&gt; &lt;artifactId&gt;common-base-utils121&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"nexus","slug":"nexus","permalink":"http://yoursite.com/tags/nexus/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"一张图学会Vim编辑器快捷键","slug":"一张图学会Vim编辑器快捷键","date":"2019-01-16T10:26:47.000Z","updated":"2019-01-16T10:35:06.174Z","comments":true,"path":"2019/01/16/一张图学会Vim编辑器快捷键/","link":"","permalink":"http://yoursite.com/2019/01/16/一张图学会Vim编辑器快捷键/","excerpt":"","text":"vim是一个平时非常实用的工具，在这里记录一下。 Vim使用快捷键组合 Vim键盘图 1、移动光标1、左移h、右移l、下移j、上移k 2、向下翻页ctrl + f，向上翻页ctrl + b 3、向下翻半页ctrl + d，向上翻半页ctrl + u 4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^ 5、移动光标到下一个句子 ），移动光标到上一个句子（ 6、移动到段首{，移动到段尾} 7、移动到下一个词w，移动到上一个词b 8、移动到文档开始gg，移动到文档结束G 9、移动到匹配的{}.().[]处% 10、跳到第n行 ngg 或 nG 或 :n 11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L 12、读取当前字符，并移动到本屏幕内下一次出现的地方 * 13、读取当前字符，并移动到本屏幕内上一次出现的地方 # 2、替换查找1、光标向后查找关键字 #或者g# 2、光标向前查找关键字 或者g 3、当前行查找字符 fx, Fx, tx, Tx 4、基本替换 :s/s1/s2 （将下一个s1替换为s2） 5、全部替换 :%s/s1/s2 6、只替换当前行 :s/s1/s2/g 7、替换某些行 :n1,n2 s/s1/s2/g 8、搜索模式为 /string，搜索下一处为n，搜索上一处为N 9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母 10、移动到某标签处 `x，1旁边的键 11、移动到上次编辑文件的位置 3、编辑操作1、光标后插入a, 行尾插入A 2、后插一行插入o，前插一行插入O 3、删除字符插入s， 删除正行插入S 4、光标前插入i，行首插入I 5、删除一行dd，删除后进入插入模式cc或者S 6、删除一个单词dw，删除一个单词进入插入模式cw 7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl 8、粘贴p，交换两个字符xp，交换两行ddp 9、复制y，复制一行yy 10、撤销u，重做ctrl + r，重复. 11、智能提示 ctrl + n 或者 ctrl + p 12、删除motion跨过的字符，删除并进入插入模式 c{motion} 13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx 14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx 15、删除motion跨过的字符，删除但不进入插入模式 d{motion} 16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx 17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx 18、如果只是复制的情况时，将12-17条中的c或d改为y 19、删除到行尾可以使用D或C 20、拷贝当前行 yy或者Y 21、删除当前字符 x 22、粘贴 p 23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy 24、重复执行上一个作用使用. 25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行 26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进 27、 &gt;&gt; 缩进所有选择的代码 28、 &lt;&lt; 反缩进所有选择的代码 29、gd 移动到光标所处的函数或变量的定义处 30、K 在man里搜索光标所在的词 31、合并两行 J 32、若不想保存文件，而重新打开 :e! 33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换 4、窗口操作1、分隔一个窗口:split或者:vsplit 2、创建一个窗口:new或者:vnew 3、在新窗口打开文件:sf {filename} 4、关闭当前窗口:close 5、仅保留当前窗口:only 6、到左边窗口 ctrl + w, h 7、到右边窗口 ctrl + w, l 8、到上边窗口 ctrl + w, k 9、到下边窗口 ctrl + w, j 10、到顶部窗口 ctrl + w, t 11、到底部窗口 ctrl + w, b 5、宏操作1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中 2、@[a-z]执行寄存器[a-z]中的操作 3、@@执行最近一次记录的宏操作 6、可视操作1、进入块可视模式 ctrl + v 2、进入字符可视模式 v 3、进入行可视模式 V 4、删除选定的块 d 5、删除选定的块然后进入插入模式 c 6、在选中的块同是插入相同的字符 IESC 7、跳到声明1、[[ 向前跳到顶格第一个{ 2、[] 向前跳到顶格第一个} 3、]] 向后跳到顶格的第一个{ 4、]] 向后跳到顶格的第一个} 5、[{ 跳到本代码块的开头 6、]} 跳到本代码块的结尾 8、挂起操作1、挂起Vim ctrl + z 或者 :suspend 2、查看任务 在shell中输入 jobs 3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台） 4、执行shell命令 :!command 5、开启shell命令 :shell，退出该shell exit 6、保存vim状态 :mksession name.vim 7、恢复vim状态 :source name.vim 8、启动vim时恢复状态 vim -S name.vim","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}],"keywords":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}]},{"title":"Java多线程编程-ReentrantReadWriteLock","slug":"Java多线程编程-ReentrantReadWriteLock","date":"2019-01-16T08:04:50.000Z","updated":"2019-01-16T09:49:02.801Z","comments":true,"path":"2019/01/16/Java多线程编程-ReentrantReadWriteLock/","link":"","permalink":"http://yoursite.com/2019/01/16/Java多线程编程-ReentrantReadWriteLock/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;上一篇已经介绍了synchronized与ReentrantLock这两种加锁模式，接下来介绍一下读写锁ReentrantReadWriteLock。 &ensp;&ensp;&ensp;&ensp;设想以下情景：我们在系统中有一个多线程访问的缓存，多个线程都可以对缓存进行读或写操作，但是读操作远远多于写操作，要求写操作要线程安全，且写操作执行完成要求对当前的所有读操作马上可见。 分析上面的需求：因为有多个线程可能会执行写操作，因此多个线程的写操作必须同步串行执行；而写操作执行完成要求对当前的所有读操作马上可见，这就意味着当有线程正在读的时候，要阻塞写操作，当正在执行写操作时，要阻塞读操作。一个简单的实现就是将数据直接加上互斥锁，同一时刻不管是读还是写线程，都只能有一个线程操作数据。但是这样的问题就是如果当前只有N个读线程，没有写线程，这N个读线程也要傻呵呵的排队读，尽管其实是可以安全并发提高效率的。&ensp;&ensp;&ensp;&ensp;因此理想的实现是：（1）当有写线程时，则写线程独占同步状态。（2）当没有写线程时只有读线程时，则多个读线程可以共享同步状态。读写锁就是为了实现这种效果而生。 1、使用示例1.1 读读共享1234567891011121314151617181920212223242526272829public class Lock extends Thread&#123; public static int ticket=10; private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void read()&#123; try &#123; lock.readLock().lock(); System.out.println(\"已经读取到了 \" +Thread.currentThread().getName()+\" \"+System.currentTimeMillis()); Thread.sleep(500); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.readLock().unlock(); &#125; &#125; public static void main(String[] args)&#123; Lock lock=new Lock(); for(int i=0;i&lt;5;i++)&#123; new Lock()&#123; @Override public void run()&#123; lock.read(); &#125; &#125;.start(); &#125; &#125;&#125; 运行结果： 12345已经读取到了 Thread-1 1547626862703已经读取到了 Thread-2 1547626862704已经读取到了 Thread-3 1547626862704已经读取到了 Thread-4 1547626862704已经读取到了 Thread-5 1547626862704 &ensp;&ensp;&ensp;&ensp;可以看出两个线程之间，获取锁的时间几乎同时，说明lock.readLock().lock(); 允许多个线程同时执行lock（）方法后面的代码。 1.2 写写互斥1234567891011121314151617181920212223242526272829public class Lock extends Thread&#123; public static int ticket=10; private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void write()&#123; try &#123; lock.writeLock().lock(); System.out.println(\"已经读取到了 \" +Thread.currentThread().getName()+\" \"+System.currentTimeMillis()); Thread.sleep(500); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.writeLock().unlock(); &#125; &#125; public static void main(String[] args)&#123; Lock lock=new Lock(); for(int i=0;i&lt;5;i++)&#123; new Lock()&#123; @Override public void run()&#123; lock.write(); &#125; &#125;.start(); &#125; &#125;&#125; 运行结果： 12345已经读取到了 Thread-1 1547627124841已经读取到了 Thread-2 1547627125345已经读取到了 Thread-3 1547627125846已经读取到了 Thread-4 1547627126351已经读取到了 Thread-5 1547627126851 &ensp;&ensp;&ensp;&ensp;可以看出执行结果大致差了500ms的时间，可以说明多个写线程是互斥的。 1.3 读写互斥或者写读互斥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Lock extends Thread&#123; public static int ticket=10; private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void read()&#123; try &#123; lock.readLock().lock(); System.out.println(\"已经读取到了 \" +Thread.currentThread().getName()+\" \"+System.currentTimeMillis()); Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.readLock().unlock(); &#125; &#125; public void write()&#123; try &#123; lock.writeLock().lock(); System.out.println(\"已经写入到了 \" +Thread.currentThread().getName()+ \" \"+System.currentTimeMillis()); Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; lock.writeLock().unlock(); &#125; &#125; public static void main(String[] args)&#123; Lock lock=new Lock(); for(int i=0;i&lt;5;i++)&#123; new Lock()&#123; @Override public void run()&#123; lock.write(); &#125; &#125;.start(); &#125; for(int i=5;i&lt;10;i++)&#123; new Lock()&#123; @Override public void run()&#123; lock.read(); &#125; &#125;.start(); &#125; &#125;&#125; 运行结果： 12345678910已经写入到了 Thread-1 1547627278293已经写入到了 Thread-2 1547627279297已经写入到了 Thread-3 1547627280300已经写入到了 Thread-4 1547627281303已经写入到了 Thread-5 1547627282307已经读取到了 Thread-6 1547627283312已经读取到了 Thread-7 1547627283312已经读取到了 Thread-8 1547627283313已经读取到了 Thread-9 1547627283313已经读取到了 Thread-10 1547627283313 &ensp;&ensp;&ensp;&ensp;可以看出先执行了写操作，然后执行读操作，写操作之间是互斥的，读操作共享的，读与写这两个动作互斥的。 2、总结 多个线程可以同时进入同一个读锁 多个线程不能同时进入同一个写锁 多个线程不能同时进入同一对读锁、写锁 一个线程可以先进入写锁、再进入读锁 一个线程可以先进入写锁、再进入读锁、再进入写锁 一个线程可以先进入读锁、再进入写锁","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"ReentrantReadWriteLock","slug":"ReentrantReadWriteLock","permalink":"http://yoursite.com/tags/ReentrantReadWriteLock/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"Java多线程编程-synchronized与ReentrantLock","slug":"Java多线程编程-1","date":"2019-01-11T08:52:36.000Z","updated":"2019-01-16T08:57:45.148Z","comments":true,"path":"2019/01/11/Java多线程编程-1/","link":"","permalink":"http://yoursite.com/2019/01/11/Java多线程编程-1/","excerpt":"","text":"1、进程与线程的概念（1）在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单位都是进程。 在未配置 OS 的系统中，程序的执行方式是顺序执行，即必须在一个程序执行完后，才允许另一个程序执行；在多道程序环境下，则允许多个程序并发执行。程序的这两种执行方式间有着显著的不同。也正是程序并发执行时的这种特征，才导致了在操作系统中引入进程的概念。 自从在 20 世纪 60 年代人们提出了进程的概念后，在 OS 中一直都是以进程作为能拥有资源和独立运行的基本单位的。直到 20 世纪 80 年代中期，人们又提出了比进程更小的能独立运行的基本单位——线程(Thread)，试图用它来提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量。特别是在进入 20 世纪 90 年代后，多处理机系统得到迅速发展，线程能比进程更好地提高程序的并行执行程度，充分地发挥多处理机的优越性，因而在近几年所推出的多处理机OS中也都引入了线程，以改善OS的性能。 —–以上摘自《计算机操作系统-汤小丹等编著-3 版》 （2）进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 （3）线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 进程与线程的关系如下图所示： 2、Java实现多线程的方式2.1、继承Thread，重写run（）方法1234567891011public class MyThread extends Thread&#123; @Override public void run()&#123; System.out.println(\"线程名字：\"+currentThread().getName()); &#125; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125; 输出结果： 线程名字：Thread-0 &ensp;&ensp;&ensp;&ensp;另外，要明白启动线程的是start（）方法而不是run（）方法，如果用run（）方法，那么他就是一个普通的方法执行了。 2.2、实现Runable接口123456789101112public class MyRunnable implements Runnable&#123; @Override public void run()&#123; System.out.println(\"线程任务\"); &#125; public static void main(String[] args)&#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); &#125;&#125; 3、线程安全&ensp;&ensp;&ensp;&ensp;线程安全概念：当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 &ensp;&ensp;&ensp;&ensp;线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。这里的加锁机制常见的如：synchronized 3.1、synchronized修饰符&ensp;&ensp;&ensp;&ensp; 在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。&ensp;&ensp;&ensp;&ensp; synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。我们接下来模拟火车站抢票的流程：（1）Runable接口加锁实现方法 1234567891011121314151617181920212223public class MyRunnable implements Runnable&#123; private int ticket=10; ReentrantLock rt=new ReentrantLock(); //第三种方法，显示加锁，效率最高 @Override public void run()&#123; synchronized (this) &#123; //防止出现线程安全的问题 ticket--; System.out.println(\"剩余\"+ticket+\"张票\"+\" \"+Thread.currentThread()); &#125; &#125; public static void main(String[] args)&#123; System.out.println(\"=========开始卖票!=========\"); MyRunnable myRunnable = new MyRunnable(); Thread thread = null; //模拟10个人抢票 for(int i=0;i&lt;10;i++)&#123; thread=new Thread(myRunnable,String.valueOf(i)); thread.start(); &#125; &#125;&#125; 我们模拟开启10个线程开始抢票，其实现结果：12345678910剩余9张票 Thread[0,5,main]剩余8张票 Thread[1,5,main]剩余7张票 Thread[2,5,main]剩余6张票 Thread[3,5,main]剩余5张票 Thread[4,5,main]剩余4张票 Thread[5,5,main]剩余3张票 Thread[6,5,main]剩余2张票 Thread[7,5,main]剩余1张票 Thread[8,5,main]剩余0张票 Thread[9,5,main] 我们来看一下不加锁（synchronized）的情况:12345678910剩余8张票 Thread[1,5,main]剩余8张票 Thread[0,5,main]剩余7张票 Thread[2,5,main]剩余6张票 Thread[3,5,main]剩余5张票 Thread[4,5,main]剩余4张票 Thread[5,5,main]剩余3张票 Thread[6,5,main]剩余2张票 Thread[7,5,main]剩余1张票 Thread[8,5,main]剩余0张票 Thread[9,5,main] 通过上面运行的结果可以看到不加锁(synchronized)的时候，出现线程不安全的问题。 (2)继承Thread实现方法(加锁synchronized)1234567891011121314151617181920212223public class MyThread extends Thread&#123; public static int ticket=10; public void getTicket()&#123; synchronized (MyThread.class) &#123; //防止出现线程安全的问题 ticket--; System.out.println(\"剩余\" + ticket + \"张票\" + \" \" + currentThread().getName()); &#125; &#125; public static void main(String[] args)&#123; //开10个人进行抢票 for(int i=0;i&lt;10;i++)&#123; MyThread thread = new MyThread()&#123; @Override public void run()&#123; getTicket(); &#125; &#125;; thread.start(); &#125; &#125;&#125; 说明： 当多个线程访问MyThread 的run方法的时候，如果使用了synchronized修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。 3.2、ReentrantLock锁的实现方案&ensp;&ensp;&ensp;&ensp;在java 5之前，一直靠synchronized关键字来实现锁功能的，处理多线程并发的问题；而在java 5之后新增了Lock接口来实现锁的功能，同时也Lock接口提供ReentrantLock实现类（可重入锁）。 &ensp;&ensp;&ensp;&ensp;与synchronized关键字相比，ReentrantLock使用时需要显式的获取或释放锁，而synchronized可以隐式获取和释放锁，也就是说，在正常使用情况下，ReentrantLock需要手动操作锁的获取和释放，synchronized可以自动的获取和释放，从操作性上synchronized是相对便捷的，居然ReentrantLock是手动的，那么也有它的优势，就是可以自定义一些其他的操作，比如中断锁的获取及超时获取锁等多种特性。 下面是关于Lock接口一些主要方法： void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。 boolean tryLock()： 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是”试图”获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法。 void unlock()： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生。 Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。 ReentrantLock的使用并不复杂，通常是加锁（获取锁）、释放同步锁即可1234567891011121314151617public class ReentrantLockTest &#123; //定义锁对象 private ReentrantLock lock=new ReentrantLock(); //定义需要保证的线程安全的方法 public void method1()&#123; //获取锁，加锁 lock.lock(); try &#123; //需要保证线程安全的代码 &#125; finally&#123; //使用finally来保证锁的释放 lock.unlock(); &#125; &#125; &#125; &ensp;&ensp;&ensp;&ensp;这一结构确保任何时刻只有一个线程进入临界区（临界区是指共享资源的代码区），一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们则被阻塞直到第一个线程释放锁对象。把解锁的操作放在finally中是十分必要的，如果在临界区发生了异常，锁是必须要释放的，否则其他线程将会永远阻塞。 使用ReentrantLock锁解决线程同步问题 针对上面买票的问题，下面可重入锁（ReentrantLock）解决: 1234567891011121314151617181920212223public class MyRunnable implements Runnable&#123; private int ticket=10; ReentrantLock rt=new ReentrantLock(); //第三种方法，显示加锁，效率最高 @Override public void run()&#123; rt.lock(); //加锁 ticket--; System.out.println(\"剩余\"+ticket+\"张票\"+\" \"+Thread.currentThread()); rt.unlock(); //解锁 &#125; public static void main(String[] args)&#123; System.out.println(\"=========开始卖票!=========\"); MyRunnable myRunnable = new MyRunnable(); Thread thread = null; //开10个线程消费抢票 for(int i=0;i&lt;10;i++)&#123; thread=new Thread(myRunnable,String.valueOf(i)); thread.start(); &#125; &#125;&#125; 打印结果：1234567891011=========开始卖票!=========剩余9张票 Thread[0,5,main]剩余8张票 Thread[3,5,main]剩余7张票 Thread[4,5,main]剩余6张票 Thread[6,5,main]剩余5张票 Thread[1,5,main]剩余4张票 Thread[7,5,main]剩余3张票 Thread[8,5,main]剩余2张票 Thread[2,5,main]剩余1张票 Thread[5,5,main]剩余0张票 Thread[9,5,main] 4、synchronized和ReentrantLock的比较 Lock一个接口，提供ReentrantLock实现类，而synchronized是个关键字，是java内置线程同步。 synchronized在发生异常时，会自动的释放线程占用锁对象，不会导致死锁的现象发生，而Lock在发生异常时，如果没有主动的通过unLock方法释放锁对象，则可能会造成死锁的发生，因此在是使用Lock时需要在finally块中释放锁。 Lock可以让等待锁的线程中断，而synchronized则不行，会一直等待下去，直到有唤醒的操作。 Lock可以判断线程是否成功获取锁对象，而synchronized则不行。 总结： ReentrantLock和synchronized相比，主要是ReentrantLock实现类定义了一些特殊的方法，从而决定了ReentrantLock在功能上比synchronized更丰富些。但缺点也是，比如上述第二点，可以反映出在一定程度上synchronized安全性和使用便捷性上好些。 ReentrantLock中的一些方法： 1234567isFair() //判断锁是否是公平锁 isLocked() //判断锁是否被任何线程获取了 isHeldByCurrentThread() //判断锁是否被当前线程获取了 hasQueuedThreads() //判断是否有线程在等待该锁 性能比较 &ensp;&ensp;&ensp;&ensp;在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized 。所以说，在具体使用时要根据适当情况选择。 &ensp;&ensp;&ensp;&ensp;在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地， 所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步 。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"Synchronized","slug":"Synchronized","permalink":"http://yoursite.com/tags/Synchronized/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"慌得一匹！教大家如何应对在线故障！","slug":"慌得一匹！教大家如何应对在线故障！","date":"2019-01-10T06:09:51.000Z","updated":"2019-01-10T06:24:04.843Z","comments":true,"path":"2019/01/10/慌得一匹！教大家如何应对在线故障！/","link":"","permalink":"http://yoursite.com/2019/01/10/慌得一匹！教大家如何应对在线故障！/","excerpt":"","text":"线上运行的Java应用突然没有响应、响应缓慢，进程突然消失，遇到这些情况应该如何应对呢？ 来自公司内部分享","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"bug修复","slug":"bug修复","permalink":"http://yoursite.com/tags/bug修复/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java分布式锁之redis实现篇","slug":"java分布式锁","date":"2019-01-09T08:03:11.000Z","updated":"2019-03-28T06:03:29.281Z","comments":true,"path":"2019/01/09/java分布式锁/","link":"","permalink":"http://yoursite.com/2019/01/09/java分布式锁/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;刚开始写这篇文章的时候其实我是拒绝的，因为我也是最近才接触这方面的知识点，实现技术本身也是雕虫小技，但是我还是觉得拿出来与大家一起分享，本着一个学习的态度吧，如果有大佬看到，请指点一二哈！ 1、前言&ensp;&ensp;&ensp;&ensp;由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，那么就要利用分布式锁来解决这些问题。所以将自己的心得体会记录下来做一个讲解和总结。希望这篇文章可以方便自己以后查阅，同时要是能帮助到刚开始接触到这方面的同学那也是很好的。 2、为什么要使用分布式锁&ensp;&ensp;&ensp;&ensp;关于分布式锁，可能绝大部分人都会或多或少涉及到。 我举二个例子：场景一：从前端界面发起一笔支付请求，如果前端没有做防重处理，那么可能在某一个时刻会有二笔一样的单子同时到达系统后台。场景二：在App中下订单的时候，点击确认之后，没反应，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。 在接收消息的时候，消息推送重复。如果处理消息的接口无法保证幂等，那么重复消费消息产生的影响可能会非常大。 &ensp;&ensp;&ensp;&ensp;为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 3、分布式锁应该具备的条件123456在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；高可用的获取锁与释放锁；高性能的获取锁与释放锁；具备可重入特性；具备锁失效机制，防止死锁；具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 4、基于redis的实现方式4.1、选择redis实现分布式锁的原因 Redis有很高的性能 Redis命令对此支持较好，实现起来比较方便 4.2、使用命令介绍（1）SETNX：SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。 （2）expire：expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 （3）delete：delete key：删除key 在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。 4.3、实现思想（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。 4.4、具体实现流程关于redis分布式锁的实现流程如下图所示： 注意：单个线程任务处理时间threadTime、获取锁的等待时间acquireTimeout、锁的过期时间timeout三者之间的关系： 1、threadTime &lt; timeout （不然会出错） 2、acquireTimeout &lt; threadTime &lt; timeout (一般标准的设置时间方法) 废话不多说，直接上代码： TestRedisLock类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TestRedisLock &#123; //redis分布式锁 public static void lock()&#123; String indentifier = null; RedisLock redisLock = null; try &#123; //toDO 增加分布式锁逻辑 redisLock = new RedisLock(RedisClient.jedisSentinelPool); //首次获取到锁是必然的 acquireTimeout 为获取锁的等待时间，如果超过此时间就放弃 timeout 为锁的过期时间 indentifier = redisLock.lockWithTimeout(\"ss_test\",500, 3000); System.out.println(Thread.currentThread()+\"尝试获取锁,indentifier:\"+indentifier); ThreadLocal&lt;AtomicInteger&gt; threadLocal = new ThreadLocal(); threadLocal.set(new AtomicInteger(0)); while (indentifier == null)&#123;//一直请求锁，直到拿到为止 threadLocal.get().getAndIncrement(); indentifier = redisLock.lockWithTimeout(\"ss_test\",500, 3000); //Thread.currentThread().sleep(100); System.out.println(Thread.currentThread()+\"尝试获取锁,indentifier:\"+indentifier+\"，第\"+threadLocal.get().get()+\"次\"); &#125; if(indentifier!=null)&#123; //拿到锁开始干活 System.out.println(Thread.currentThread()+\"获取到锁,indentifier:\"+indentifier); Thread.currentThread().sleep(2000); //System.out.println(1/0); //todo 执行任务 System.out.println(Thread.currentThread()+\"执行完成\"); &#125;else &#123; System.out.println(Thread.currentThread()+\"没有获取到锁\"); &#125; &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; finally &#123; if(redisLock!=null &amp;&amp; StringUtils.isNotEmpty(indentifier))&#123; redisLock.releaseLock(\"ss_test\",indentifier); System.out.println(Thread.currentThread()+\"释放锁\"); &#125; &#125; &#125; //todo 线程锁 public static void main(String[] args) &#123; //模拟100人抢购 for (int i=0;i&lt;5;i++)&#123; Thread thread = new Thread()&#123; @Override public void run()&#123; lock(); &#125; &#125;; thread.start(); &#125; &#125;&#125; RedisLock类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class RedisLock &#123; private final JedisPool jedisPool; private static final Logger logger = Logger.getLogger(RedisLock.class); public RedisLock(JedisPool jedisPool) &#123; this.jedisPool = jedisPool; &#125; /** * * @param locaName 锁的key * @param acquireTimeout 尝试获取锁超时时间 * @param timeout key的超时时间 * @return 锁标识 */ public String lockWithTimeout(String locaName, long acquireTimeout, long timeout) &#123; Jedis conn = null; String retIdentifier = null; try &#123; // 获取连接 // 随机生成一个value String identifier = UUID.randomUUID().toString(); //如果identifier存在则成功获取到锁，否则表明该锁已经被其他线程占用 // 锁名，即key值 String lockKey = \"lock:\" + locaName; // 超时时间，上锁后超过此时间则自动释放锁 int lockExpire = (int)(timeout / 1000); conn = jedisPool.getResource(); // 获取锁的超时时间，超过这个时间则放弃获取锁 long end = System.currentTimeMillis() + acquireTimeout; while (System.currentTimeMillis() &lt; end) &#123; //Jedis conn = jedisPool.getResource(); //System.out.println(\"等待时间:\"+System.currentTimeMillis()); if (conn.setnx(lockKey, identifier) == 1) &#123; conn.expire(lockKey, lockExpire); // 返回value值，用于释放锁时间确认 retIdentifier = identifier; /*if (conn != null) &#123; conn.close(); //System.out.println(\"关闭连接\"); &#125;*/ return retIdentifier; &#125; // 返回-1代表key没有设置超时时间，为key设置一个超时时间 if (conn.ttl(lockKey) == -1) &#123; conn.expire(lockKey, lockExpire); &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); logger.error(\"RedisLock中断异常\",e); &#125; /* if (conn != null) &#123; conn.close(); //System.out.println(\"关闭连接\"); &#125;*/ &#125; &#125; catch (JedisException e) &#123; logger.error(\"RedisLock获取锁异常\",e); //jedisPool.returnBrokenResource(conn); &#125; finally &#123; if (conn != null) &#123; conn.close(); // System.out.println(\"关闭连接\"); &#125; &#125; return retIdentifier; &#125; /** * 释放锁 * @param lockName 锁的key * @param identifier 释放锁的标识 * @return */ public boolean releaseLock(String lockName, String identifier) &#123; Jedis conn = null; String lockKey = \"lock:\" + lockName; boolean retFlag = false; try &#123; conn = jedisPool.getResource(); while (true) &#123; // 监视lock，准备开始事务 conn.watch(lockKey); // 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁 if (identifier.equals(conn.get(lockKey))) &#123; Transaction transaction = conn.multi(); transaction.del(lockKey); List&lt;Object&gt; results = transaction.exec(); if (results == null) &#123; continue; &#125; retFlag = true; &#125; conn.unwatch(); break; &#125; &#125; catch (JedisException e) &#123; logger.error(\"RedisLock释放锁异常\",e); &#125; finally &#123; if (conn != null) &#123; conn.close(); &#125; &#125; return retFlag; &#125;&#125; 本次测试模拟五个线程，acquireTimeout = 2500， threadTime = 2700 ， timeout = 3000 实验结果如下： 5、小结&ensp;&ensp;&ensp;&ensp;在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。 当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"【深度好文】simhash文本去重流程","slug":"simhash","date":"2019-01-06T12:37:41.000Z","updated":"2019-01-16T03:58:40.134Z","comments":true,"path":"2019/01/06/simhash/","link":"","permalink":"http://yoursite.com/2019/01/06/simhash/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;本人目前就职于某厂新闻客户端，对于新闻客户端而言，推荐的每一刷的新闻都必须是不同的新闻，这就需要对新闻文本进行排重。传统的去重一般是对文章的url链接进行排重，但是对于抓取的网页来说，各大平台的新闻可能存在重复，对于只通过文章url进行排重是不靠谱的，为了解决这个痛点于是就提出了用simhash来解决这个难题。 1.简介&ensp;&ensp;&ensp;&ensp;传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。即便是两个原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统的Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感hash，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 Detecting Near-Duplicates for Web Crawling 论文中所说），一般海明距离为3就代表两篇文章相同。&ensp;&ensp;&ensp;&ensp;simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。 2.背景 如何设计一个比较两篇文章相似度的算法？可能你会回答几个比较传统点的思路: 一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离（可以计算它们之间的欧氏距离、海明距离或者夹角余弦等等），从而通过距离的大小来判断两篇文章的相似度。 另外一种是传统hash，我们考虑为每一个web文档通过hash的方式生成一个指纹（finger print）。 下面我们来分析一下这两种方法: 采取第一种方法，若是只比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度。你还会去计算任意两个网页之间的距离或夹角余弦么？那样做的话时间复杂度，空间复杂度可想而知。 而第二种方案中所说的传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化。 3.simhash与hash算法的区别&ensp;&ensp;&ensp;&ensp;传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。&ensp;&ensp;&ensp;&ensp;我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 4.simhash原理 simhash是google用来处理海量文本去重的算法。 google出品，你懂的。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是&lt;n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。 算法过程大致如下： 1，对文本分词，得到N维特征向量（默认为64维） 2，为分词设置权重（tf-idf） 3，为特征向量计算哈希 4，对所有特征向量加权，累加（目前仅进行非加权累加） 5，对累加结果，大于零置一，小于零置零 6，得到文本指纹（fingerprint） 具体流程实现 simhash的算法具体分为5个步骤：分词、hash、加权、合并、降维，具体过程如下： 分词 给定一段语句或者一段文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如给定一段语句：“生活本没有路，走的人多了就成了路，要相信阳光总在风雨后”，分词后结果为：生活 没有 成了 相信 阳光 风雨，然后为每个特征向量赋予权值：生活(5) 没有(2) 成了(1) 相信(2) 阳光(3) 风雨(2)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 hash 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“生活”的hash值Hash(生活)为110101，“没有”的hash值Hash(没有)为“101001”。就这样，字符串就变成了一系列数字。 加权 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“生活”的hash值“110101”加权得到：W(生活) = 110101 5 = 5 5 -5 5 -5 5，给“没有”的hash值“101001”加权得到：W(没有)=101001 2 = 2 -2 2 -2 -2 2，其余特征向量类似此般操作。 合并 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“生活”的“5 5 -5 5 -5 5”和“没有”的“2 -2 2 -2 -2 2”进行累加，得到“5+2 5-2 -5+2 5-2 -5-2 5+2”，得到“7 3 -3 3 -7 7”。 降维 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 1 0 1 0 1”，从而形成它们的simhash签名。 整个过程的流程图为： 5、simhash的签名距离计算&ensp;&ensp;&ensp;&ensp;我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： 10101 和 00110 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。 &ensp;&ensp;&ensp;&ensp;我们可以把 64 位的二进制simhash签名均分成4块，每块16位。根据鸽巢原理（也称抽屉原理），如果两个签名的海明距离在 3 以内，它们必有一块完全相同。如下图所示： 6、simhash的存储和查找 我们需要将64位simhash均分为4份，然后每份作为key存储到redis 采用精确匹配的方式查找前16位 找到则拿出来计算与被比较的simahsh距离，小于3则判断为相似（当然具体问题具体分析，这个值可以调整） 如果样本库中存有2^34（差不多10亿）的哈希指纹，则每个table返回2^(34-16)=262144个候选结果，大大减少了海明距离的计算成本 7、聊聊Jaccard相似度与汉明距离7.1 Jaccard相似度&ensp;&ensp;&ensp;&ensp; Jaccard 系数，又叫Jaccard相似性系数，用来比较样本集中的相似性和分散性的一个概率。公式： 给定两个集合A,B jaccard 系数定义为A与B交集的大小与并集大小的比值，jaccard值越大说明相似度越高 7.2 汉明距离&ensp;&ensp;&ensp;&ensp;在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以d(x, y)表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串x变成y所需要的最小的替换次数。 12345举例说明以下字符串间的汉明距离为：&quot;karolin&quot; and &quot;kathrin&quot; is 3.&quot;karolin&quot; and &quot;kerstin&quot; is 3.1011101 and 1001001 is 2.2173896 and 2233796 is 3. 8、【实战】新闻文本去重服务详细流程&ensp;&ensp;&ensp;&ensp;上面陆陆续续讲了这么多理论知识想必大家也是一头雾水，接下来我们通过实战来讲述整体流程。 &ensp;&ensp;&ensp;&ensp;本文将文本排重做成了一个接口，首先给去重接口传一些必要的参数，针对新闻文本为例（url:链接 title:文本标题 content:内容）。依次是进行url排重、title排重、content排重，如果三种都没有找到，则建立url、title、content索引存储到redis。具体流程图如下： 8.1、URL排重 建立URL索引： 12key: url_index_name+&quot;_&quot;+urlMD5。url_index_name为索引名字，urlMD5表示url的MD5值value: docId+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，url表示新闻链接，storageTime表示存入redis的时间戳 根据urlMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.2、Title排重 建立Title索引： 12key: title_index_name+&quot;_&quot;+titleMD5。title_index_name为索引名字，titleMD5表示title的MD5值value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 根据titleMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.3、Content排重 建立Content索引： 1234先将64位simhash值均分为4份：simHashFragment1、simHashFragment2、simHashFragment3、simHashFragment4key: content_index_name+&quot;_&quot;+simHashFragment。content_index_name为索引名字，simHashFragment表示其中一段simhash值（16位）value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+simhash+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 然后将这4份索引存储到redis(LIST) 根据simHashFragment索引从redis里面查找（4份simhash索引都得一起召回） 将召回的值依次与带排重的文本比对 hanmingDistance&lt;=H 并且 jarccardSimilary&gt;=J 召回(一般设置H=10,J=0.7 具体情况具体分析) 注：三天内新闻做法 hanmingDistance&lt;=3 并且 jarccardSimilary&gt;=0.7 注：三天外新闻做法 将召回的新闻做rank（这里不细讲，方法很多），TOP1作为排重的新闻 9、总结&ensp;&ensp;&ensp;&ensp;现如今是一个信息过载的时代，高效的从海量文本里面快速找到相似的文本是一个需要解决的一个痛点，simhash的存在就很好的解决了这个问题。 &ensp;&ensp;&ensp;&ensp;由于simhash是局部敏感的hash，其可能不适合做这种短标题的重复度判断，会存在一定的误差，文本越长判断的准确率越高。 好记性不如烂笔头，记录点滴！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"文本去重","slug":"文本去重","permalink":"http://yoursite.com/tags/文本去重/"},{"name":"simhash","slug":"simhash","permalink":"http://yoursite.com/tags/simhash/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"markdown基本语法","slug":"markdown基本语法","date":"2019-01-05T13:31:07.000Z","updated":"2019-01-08T10:05:38.100Z","comments":true,"path":"2019/01/05/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/01/05/markdown基本语法/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp; markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 优点 因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持markdown编辑模式。 一、标题&ensp;&ensp;&ensp;&ensp; 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三、引用在引用的文字前加&gt;即可。示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。示例： 12345-------******** 五、图片语法：123![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：12[搜狐](http://www.souhu.com)[百度](http://www.baidu.com) 七、列表无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：12345| 水果 | 价格 | 数量 | | -------- | -----: | :----: | | 香蕉 | $1 | 5 | | 苹果 | $1 | 6 | | 草莓 | $1 | 7 | 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容` python 代码块12345a = range(2000)for i in a: if i % 2 == 0: continue print(i + 1) java 代码块123456789private URLInfo extractURLHost(String url)&#123; URLInfo urlInfo = new URLInfo(); String host = HostDomainExtractKit.extractURLHost(url); String domain = HostDomainExtractKit.getTopLevelDomain(url); urlInfo.setHost(host); urlInfo.setDomain(domain); return urlInfo; &#125; 十、流程图一般写法：1234567st=&gt;start: Startop=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;Endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 注：MarkDown没 有统一标准，不同网站实现的方式不同，目前github上写markdown，并没有实现流程图的语法。","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}]},{"title":"ubuntu下安装PyV8","slug":"pyv8","date":"2019-01-03T15:42:15.000Z","updated":"2019-01-08T10:05:38.093Z","comments":true,"path":"2019/01/03/pyv8/","link":"","permalink":"http://yoursite.com/2019/01/03/pyv8/","excerpt":"","text":"这几天需要使用PyV8来进行python与javascript的交互，在ubuntu上面安装遇到了不少的坑，折腾几小时终于找到方法。 安装依赖123$ sudo apt-get install scons$ sudo apt-get install libboost-dev libboost-thread-dev$ sudo apt-get install libboost-system-dev libboost-python-dev 安装Pyv8&ensp;&ensp;&ensp;&ensp;下载二进制文件github找到适合你机器的版本下载。解压出来应该有两个文件：PyV8.py , _PyV8.so,然后把这两个文件拷贝到你的python第三方包的目录里面就好，比如我的是:12$ cd pyv8$ sudo cp * /usr/lib/python2.7/dist-packages/ &ensp;&ensp;&ensp;然后进入到python环境测试如下代码:123456789101112import PyV8ctxt = PyV8.JSContext()ctxt.enter()func = ctxt.eval(\"\"\"(function()&#123; function hello()&#123; return \"Hello world.\"; &#125; return hello(); &#125;) \"\"\")print func() 执行输出Hello World说明安装成功了，就可以模拟JS代码了。 好记性不如烂笔头，记录点滴！","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"pyv8","slug":"pyv8","permalink":"http://yoursite.com/tags/pyv8/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"hexo一个错误解","slug":"error","date":"2019-01-02T15:42:15.000Z","updated":"2019-01-08T10:05:38.107Z","comments":true,"path":"2019/01/02/error/","link":"","permalink":"http://yoursite.com/2019/01/02/error/","excerpt":"","text":"今天进入到博客目录，发现hexo命令行用不了了，报如下错误： ERROR Local hexo not found in ~/Downloads/hexo/blog ERROR Try running: ‘npm install hexo –save’ 解决办法 rm -rf node_modules npm install ok,至此hexo命令已经可以运行，问题解决！ 好记性不如烂笔头，记录点滴！","categories":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}]},{"title":"smilemilk的第一次博客之旅","slug":"hello-world","date":"2019-01-01T01:42:15.000Z","updated":"2019-01-10T08:56:06.019Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/01/hello-world/","excerpt":"","text":"在这里我将会和大家在接下来的日子里面一起分享自己的爬虫+搜索+大数据方面的工程经验， &ensp;&ensp;&ensp;&ensp;本来2018年就想写点自己的东西一直拖到2019年（🤦捂脸。。。♀)，主要是因为2018年整个在忙实习还有硕士毕业的各种事情。转眼就到 2019 年了，其实我没有写总结的习惯，现在到头来还是蛮后悔的，说实话总结其实还是蛮有必要的，现在就趁着这个时间来立一下 2019 的 Flag，再等到 2020 年翻出来打脸吧，哈哈😄。 35岁之前只做能提高自己技术水平的事情，能够成为公认的某一个技术领域的专家。不随波逐流，要独树一帜。 优质博客： zsythink 崔庆才 rowkey 徐刘根 好记性不如烂笔头，接下来我的博客将会陆续更新，博客还在施工中，敬请期待！！","categories":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}],"tags":[],"keywords":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}]}]}
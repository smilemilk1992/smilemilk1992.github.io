{"meta":{"title":"smilemilk","subtitle":"大数据 · Python · 技术博客","description":"good good learn, day day up!","author":"Chen Hao","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-11-24T07:44:33.000Z","updated":"2017-11-28T11:28:18.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-11-27T15:29:11.000Z","updated":"2017-11-27T15:43:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-27T15:01:30.000Z","updated":"2017-11-27T15:42:10.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java分布式锁","slug":"java分布式锁","date":"2019-01-09T08:03:11.000Z","updated":"2019-01-09T08:06:21.980Z","comments":true,"path":"2019/01/09/java分布式锁/","link":"","permalink":"http://yoursite.com/2019/01/09/java分布式锁/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"【深度好文】simhash文本去重流程","slug":"simhash","date":"2019-01-06T12:37:41.000Z","updated":"2019-01-09T08:06:55.184Z","comments":true,"path":"2019/01/06/simhash/","link":"","permalink":"http://yoursite.com/2019/01/06/simhash/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;本人目前就职于某厂新闻客户端，对于新闻客户端而言，推荐的每一刷的新闻都必须是不同的新闻，这就需要对新闻文本进行排重。传统的去重一般是对文章的url链接进行排重，但是对于抓取的网页来说，各大平台的新闻可能存在重复，对于只通过文章url进行排重是不靠谱的，为了解决这个痛点于是就提出了用simhash来解决这个难题。 1.简介&ensp;&ensp;&ensp;&ensp;传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。即便是两个原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统的Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感hash，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 Detecting Near-Duplicates for Web Crawling 论文中所说），一般海明距离为3就代表两篇文章相同。&ensp;&ensp;&ensp;&ensp;simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。 2.背景 如何设计一个比较两篇文章相似度的算法？可能你会回答几个比较传统点的思路: 一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离（可以计算它们之间的欧氏距离、海明距离或者夹角余弦等等），从而通过距离的大小来判断两篇文章的相似度。 另外一种是传统hash，我们考虑为每一个web文档通过hash的方式生成一个指纹（finger print）。 下面我们来分析一下这两种方法: 采取第一种方法，若是只比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度。你还会去计算任意两个网页之间的距离或夹角余弦么？那样做的话时间复杂度，空间复杂度可想而知。 而第二种方案中所说的传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化。 3.simhash与hash算法的区别&ensp;&ensp;&ensp;&ensp;传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。&ensp;&ensp;&ensp;&ensp;我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 4.simhash原理 simhash是google用来处理海量文本去重的算法。 google出品，你懂的。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是&lt;n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。 算法过程大致如下： 1，对文本分词，得到N维特征向量（默认为64维） 2，为分词设置权重（tf-idf） 3，为特征向量计算哈希 4，对所有特征向量加权，累加（目前仅进行非加权累加） 5，对累加结果，大于零置一，小于零置零 6，得到文本指纹（fingerprint） 具体流程实现 simhash的算法具体分为5个步骤：分词、hash、加权、合并、降维，具体过程如下： 分词 给定一段语句或者一段文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如给定一段语句：“生活本没有路，走的人多了就成了路，要相信阳光总在风雨后”，分词后结果为：生活 没有 成了 相信 阳光 风雨，然后为每个特征向量赋予权值：生活(5) 没有(2) 成了(1) 相信(2) 阳光(3) 风雨(2)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 hash 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“生活”的hash值Hash(生活)为110101，“没有”的hash值Hash(没有)为“101001”。就这样，字符串就变成了一系列数字。 加权 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“生活”的hash值“110101”加权得到：W(生活) = 110101 5 = 5 5 -5 5 -5 5，给“没有”的hash值“101001”加权得到：W(没有)=101001 2 = 2 -2 2 -2 -2 2，其余特征向量类似此般操作。 合并 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“生活”的“5 5 -5 5 -5 5”和“没有”的“2 -2 2 -2 -2 2”进行累加，得到“5+2 5-2 -5+2 5-2 -5-2 5+2”，得到“7 3 -3 3 -7 7”。 降维 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 1 0 1 0 1”，从而形成它们的simhash签名。 整个过程的流程图为： 5、simhash的签名距离计算&ensp;&ensp;&ensp;&ensp;我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： 10101 和 00110 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。 &ensp;&ensp;&ensp;&ensp;我们可以把 64 位的二进制simhash签名均分成4块，每块16位。根据鸽巢原理（也称抽屉原理），如果两个签名的海明距离在 3 以内，它们必有一块完全相同。如下图所示： 6、simhash的存储和查找 我们需要将64位simhash均分为4份，然后每份作为key存储到redis 采用精确匹配的方式查找前16位 找到则拿出来计算与被比较的simahsh距离，小于3则判断为相似（当然具体问题具体分析，这个值可以调整） 如果样本库中存有2^34（差不多10亿）的哈希指纹，则每个table返回2^(34-16)=262144个候选结果，大大减少了海明距离的计算成本 7、聊聊Jaccard相似度与汉明距离7.1 Jaccard相似度&ensp;&ensp;&ensp;&ensp; Jaccard 系数，又叫Jaccard相似性系数，用来比较样本集中的相似性和分散性的一个概率。公式： 给定两个集合A,B jaccard 系数定义为A与B交集的大小与并集大小的比值，jaccard值越大说明相似度越高 7.2 汉明距离&ensp;&ensp;&ensp;&ensp;在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以d(x, y)表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串x变成y所需要的最小的替换次数。 12345举例说明以下字符串间的汉明距离为：&quot;karolin&quot; and &quot;kathrin&quot; is 3.&quot;karolin&quot; and &quot;kerstin&quot; is 3.1011101 and 1001001 is 2.2173896 and 2233796 is 3. 8、【实战】新闻文本去重服务详细流程&ensp;&ensp;&ensp;&ensp;上面陆陆续续讲了这么多理论知识想必大家也是一头雾水，接下来我们通过实战来讲述整体流程。 &ensp;&ensp;&ensp;&ensp;本文将文本排重做成了一个接口，首先给去重接口传一些必要的参数，针对新闻文本为例（url:链接 title:文本标题 content:内容）。依次是进行url排重、title排重、content排重，如果三种都没有找到，则建立url、title、content索引存储到redis。具体流程图如下： 8.1、URL排重 建立URL索引： 12key: url_index_name+&quot;_&quot;+urlMD5。url_index_name为索引名字，urlMD5表示url的MD5值value: docId+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，url表示新闻链接，storageTime表示存入redis的时间戳 根据urlMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.2、Title排重 建立Title索引： 12key: title_index_name+&quot;_&quot;+titleMD5。title_index_name为索引名字，titleMD5表示title的MD5值value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 根据titleMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.3、Content排重 建立Content索引： 1234先将64位simhash值均分为4份：simHashFragment1、simHashFragment2、simHashFragment3、simHashFragment4key: content_index_name+&quot;_&quot;+simHashFragment。content_index_name为索引名字，simHashFragment表示其中一段simhash值（16位）value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+simhash+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 然后将这4份索引存储到redis(LIST) 根据simHashFragment索引从redis里面查找（4份simhash索引都得一起召回） 将召回的值依次与带排重的文本比对 hanmingDistance&lt;=H 并且 jarccardSimilary&gt;=J 召回(一般设置H=10,J=0.7 具体情况具体分析) 注：三天内新闻做法 hanmingDistance&lt;=3 并且 jarccardSimilary&gt;=0.7 注：三天外新闻做法 将召回的新闻做rank（这里不细讲，方法很多），TOP1作为排重的新闻 9、总结&ensp;&ensp;&ensp;&ensp;现如今是一个信息过载的时代，高效的从海量文本里面快速找到相似的文本是一个需要解决的一个痛点，simhash的存在就很好的解决了这个问题。 &ensp;&ensp;&ensp;&ensp;由于simhash是局部敏感的hash，其可能不适合做这种短标题的重复度判断，会存在一定的误差，文本越长判断的准确率越高。 好记性不如烂笔头，记录点滴！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"文本去重","slug":"文本去重","permalink":"http://yoursite.com/tags/文本去重/"},{"name":"simhash","slug":"simhash","permalink":"http://yoursite.com/tags/simhash/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"markdown基本语法","slug":"markdown基本语法","date":"2019-01-05T13:31:07.000Z","updated":"2019-01-08T10:05:38.100Z","comments":true,"path":"2019/01/05/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/01/05/markdown基本语法/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp; markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 优点 因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持markdown编辑模式。 一、标题&ensp;&ensp;&ensp;&ensp; 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三、引用在引用的文字前加&gt;即可。示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。示例： 12345-------******** 五、图片语法：123![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：12[搜狐](http://www.souhu.com)[百度](http://www.baidu.com) 七、列表无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：12345| 水果 | 价格 | 数量 | | -------- | -----: | :----: | | 香蕉 | $1 | 5 | | 苹果 | $1 | 6 | | 草莓 | $1 | 7 | 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容` python 代码块12345a = range(2000)for i in a: if i % 2 == 0: continue print(i + 1) java 代码块123456789private URLInfo extractURLHost(String url)&#123; URLInfo urlInfo = new URLInfo(); String host = HostDomainExtractKit.extractURLHost(url); String domain = HostDomainExtractKit.getTopLevelDomain(url); urlInfo.setHost(host); urlInfo.setDomain(domain); return urlInfo; &#125; 十、流程图一般写法：1234567st=&gt;start: Startop=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;Endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 注：MarkDown没 有统一标准，不同网站实现的方式不同，目前github上写markdown，并没有实现流程图的语法。","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}]},{"title":"ubuntu下安装PyV8","slug":"pyv8","date":"2019-01-03T15:42:15.000Z","updated":"2019-01-08T10:05:38.093Z","comments":true,"path":"2019/01/03/pyv8/","link":"","permalink":"http://yoursite.com/2019/01/03/pyv8/","excerpt":"","text":"这几天需要使用PyV8来进行python与javascript的交互，在ubuntu上面安装遇到了不少的坑，折腾几小时终于找到方法。 安装依赖123$ sudo apt-get install scons$ sudo apt-get install libboost-dev libboost-thread-dev$ sudo apt-get install libboost-system-dev libboost-python-dev 安装Pyv8&ensp;&ensp;&ensp;&ensp;下载二进制文件github找到适合你机器的版本下载。解压出来应该有两个文件：PyV8.py , _PyV8.so,然后把这两个文件拷贝到你的python第三方包的目录里面就好，比如我的是:12$ cd pyv8$ sudo cp * /usr/lib/python2.7/dist-packages/ &ensp;&ensp;&ensp;然后进入到python环境测试如下代码:123456789101112import PyV8ctxt = PyV8.JSContext()ctxt.enter()func = ctxt.eval(\"\"\"(function()&#123; function hello()&#123; return \"Hello world.\"; &#125; return hello(); &#125;) \"\"\")print func() 执行输出Hello World说明安装成功了，就可以模拟JS代码了。 好记性不如烂笔头，记录点滴！","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"pyv8","slug":"pyv8","permalink":"http://yoursite.com/tags/pyv8/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"hexo一个错误解","slug":"error","date":"2019-01-02T15:42:15.000Z","updated":"2019-01-08T10:05:38.107Z","comments":true,"path":"2019/01/02/error/","link":"","permalink":"http://yoursite.com/2019/01/02/error/","excerpt":"","text":"今天进入到博客目录，发现hexo命令行用不了了，报如下错误： ERROR Local hexo not found in ~/Downloads/hexo/blog ERROR Try running: ‘npm install hexo –save’ 解决办法 rm -rf node_modules npm install ok,至此hexo命令已经可以运行，问题解决！ 好记性不如烂笔头，记录点滴！","categories":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}]},{"title":"smilemilk的第一次博客之旅","slug":"hello-world","date":"2019-01-01T01:42:15.000Z","updated":"2019-01-09T08:10:39.767Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/01/hello-world/","excerpt":"","text":"在这里我将会和大家在接下来的日子里面一起分享自己的爬虫+搜索+大数据方面的工程经验， &ensp;&ensp;&ensp;&ensp;本来2018年就想写点自己的东西一直拖到2019年（🤦捂脸。。。♀)，主要是因为2018年整个在忙实习还有硕士毕业的各种事情。转眼就到 2019 年了，其实我没有写总结的习惯，现在到头来还是蛮后悔的，说实话总结其实还是蛮有必要的，现在就趁着这个时间来立一下 2019 的 Flag，再等到 2020 年翻出来打脸吧，哈哈😄。 好记性不如烂笔头，接下来我的博客将会陆续更新，博客还在施工中，敬请期待！！","categories":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}],"tags":[],"keywords":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}]}]}
{"meta":{"title":"smilemilk","subtitle":"大数据 · Python · 技术博客","description":"good good learn, day day up!","author":"Chen Hao","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-11-27T15:29:11.000Z","updated":"2017-11-27T15:43:26.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-11-24T07:44:33.000Z","updated":"2017-11-28T11:28:18.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-27T15:01:30.000Z","updated":"2017-11-27T15:42:10.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java多线程编程-synchronized与ReentrantLock","slug":"Java多线程编程-1","date":"2019-01-11T08:52:36.000Z","updated":"2019-01-11T02:39:30.599Z","comments":true,"path":"2019/01/11/Java多线程编程-1/","link":"","permalink":"http://yoursite.com/2019/01/11/Java多线程编程-1/","excerpt":"","text":"1、进程与线程的概念（1）在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单位都是进程。 在未配置 OS 的系统中，程序的执行方式是顺序执行，即必须在一个程序执行完后，才允许另一个程序执行；在多道程序环境下，则允许多个程序并发执行。程序的这两种执行方式间有着显著的不同。也正是程序并发执行时的这种特征，才导致了在操作系统中引入进程的概念。 自从在 20 世纪 60 年代人们提出了进程的概念后，在 OS 中一直都是以进程作为能拥有资源和独立运行的基本单位的。直到 20 世纪 80 年代中期，人们又提出了比进程更小的能独立运行的基本单位——线程(Thread)，试图用它来提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量。特别是在进入 20 世纪 90 年代后，多处理机系统得到迅速发展，线程能比进程更好地提高程序的并行执行程度，充分地发挥多处理机的优越性，因而在近几年所推出的多处理机OS中也都引入了线程，以改善OS的性能。 —–以上摘自《计算机操作系统-汤小丹等编著-3 版》 （2）进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 （3）线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 进程与线程的关系如下图所示： 2、Java实现多线程的方式2.1、继承Thread，重写run（）方法1234567891011public class MyThread extends Thread&#123; @Override public void run()&#123; System.out.println(\"线程名字：\"+currentThread().getName()); &#125; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125; 输出结果： 线程名字：Thread-0 &ensp;&ensp;&ensp;&ensp;另外，要明白启动线程的是start（）方法而不是run（）方法，如果用run（）方法，那么他就是一个普通的方法执行了。 2.2、实现Runable接口123456789101112public class MyRunnable implements Runnable&#123; @Override public void run()&#123; System.out.println(\"线程任务\"); &#125; public static void main(String[] args)&#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); &#125;&#125; 3、线程安全&ensp;&ensp;&ensp;&ensp;线程安全概念：当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 &ensp;&ensp;&ensp;&ensp;线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。这里的加锁机制常见的如：synchronized 3.1、synchronized修饰符&ensp;&ensp;&ensp;&ensp; synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。我们接下来模拟火车站抢票的流程：（1）Runable接口加锁实现方法 1234567891011121314151617181920212223public class MyRunnable implements Runnable&#123; private int ticket=10; ReentrantLock rt=new ReentrantLock(); //第三种方法，显示加锁，效率最高 @Override public void run()&#123; synchronized (this) &#123; //防止出现线程安全的问题 ticket--; System.out.println(\"剩余\"+ticket+\"张票\"+\" \"+Thread.currentThread()); &#125; &#125; public static void main(String[] args)&#123; System.out.println(\"=========开始卖票!=========\"); MyRunnable myRunnable = new MyRunnable(); Thread thread = null; //模拟10个人抢票 for(int i=0;i&lt;10;i++)&#123; thread=new Thread(myRunnable,String.valueOf(i)); thread.start(); &#125; &#125;&#125; 我们模拟开启10个线程开始抢票，其实现结果：12345678910剩余9张票 Thread[0,5,main]剩余8张票 Thread[1,5,main]剩余7张票 Thread[2,5,main]剩余6张票 Thread[3,5,main]剩余5张票 Thread[4,5,main]剩余4张票 Thread[5,5,main]剩余3张票 Thread[6,5,main]剩余2张票 Thread[7,5,main]剩余1张票 Thread[8,5,main]剩余0张票 Thread[9,5,main] 我们来看一下不加锁（synchronized）的情况:12345678910剩余8张票 Thread[1,5,main]剩余8张票 Thread[0,5,main]剩余7张票 Thread[2,5,main]剩余6张票 Thread[3,5,main]剩余5张票 Thread[4,5,main]剩余4张票 Thread[5,5,main]剩余3张票 Thread[6,5,main]剩余2张票 Thread[7,5,main]剩余1张票 Thread[8,5,main]剩余0张票 Thread[9,5,main] 通过上面运行的结果可以看到不加锁(synchronized)的时候，出现线程不安全的问题。 (2)继承Thread实现方法(加锁synchronized)1234567891011121314151617181920212223public class MyThread extends Thread&#123; public static int ticket=10; public void getTicket()&#123; synchronized (MyThread.class) &#123; //防止出现线程安全的问题 ticket--; System.out.println(\"剩余\" + ticket + \"张票\" + \" \" + currentThread().getName()); &#125; &#125; public static void main(String[] args)&#123; //开10个人进行抢票 for(int i=0;i&lt;10;i++)&#123; MyThread thread = new MyThread()&#123; @Override public void run()&#123; getTicket(); &#125; &#125;; thread.start(); &#125; &#125;&#125; 说明： 当多个线程访问MyThread 的run方法的时候，如果使用了synchronized修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。 3.2、ReentrantLock锁的实现方案&ensp;&ensp;&ensp;&ensp;在java 5之前，一直靠synchronized关键字来实现锁功能的，处理多线程并发的问题；而在java 5之后新增了Lock接口来实现锁的功能，同时也Lock接口提供ReentrantLock实现类（可重入锁）。 &ensp;&ensp;&ensp;&ensp;与synchronized关键字相比，ReentrantLock使用时需要显式的获取或释放锁，而synchronized可以隐式获取和释放锁，也就是说，在正常使用情况下，ReentrantLock需要手动操作锁的获取和释放，synchronized可以自动的获取和释放，从操作性上synchronized是相对便捷的，居然ReentrantLock是手动的，那么也有它的优势，就是可以自定义一些其他的操作，比如中断锁的获取及超时获取锁等多种特性。 下面是关于Lock接口一些主要方法： void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。 boolean tryLock()： 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是”试图”获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法。 void unlock()： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生。 Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。 ReentrantLock的使用并不复杂，通常是加锁（获取锁）、释放同步锁即可1234567891011121314151617public class ReentrantLockTest &#123; //定义锁对象 private ReentrantLock lock=new ReentrantLock(); //定义需要保证的线程安全的方法 public void method1()&#123; //获取锁，加锁 lock.lock(); try &#123; //需要保证线程安全的代码 &#125; finally&#123; //使用finally来保证锁的释放 lock.unlock(); &#125; &#125; &#125; &ensp;&ensp;&ensp;&ensp;这一结构确保任何时刻只有一个线程进入临界区（临界区是指共享资源的代码区），一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们则被阻塞直到第一个线程释放锁对象。把解锁的操作放在finally中是十分必要的，如果在临界区发生了异常，锁是必须要释放的，否则其他线程将会永远阻塞。 使用ReentrantLock锁解决线程同步问题 针对上面买票的问题，下面可重入锁（ReentrantLock）解决: 1234567891011121314151617181920212223public class MyRunnable implements Runnable&#123; private int ticket=10; ReentrantLock rt=new ReentrantLock(); //第三种方法，显示加锁，效率最高 @Override public void run()&#123; rt.lock(); //加锁 ticket--; System.out.println(\"剩余\"+ticket+\"张票\"+\" \"+Thread.currentThread()); rt.unlock(); //解锁 &#125; public static void main(String[] args)&#123; System.out.println(\"=========开始卖票!=========\"); MyRunnable myRunnable = new MyRunnable(); Thread thread = null; //开10个线程消费抢票 for(int i=0;i&lt;10;i++)&#123; thread=new Thread(myRunnable,String.valueOf(i)); thread.start(); &#125; &#125;&#125; 打印结果：1234567891011=========开始卖票!=========剩余9张票 Thread[0,5,main]剩余8张票 Thread[3,5,main]剩余7张票 Thread[4,5,main]剩余6张票 Thread[6,5,main]剩余5张票 Thread[1,5,main]剩余4张票 Thread[7,5,main]剩余3张票 Thread[8,5,main]剩余2张票 Thread[2,5,main]剩余1张票 Thread[5,5,main]剩余0张票 Thread[9,5,main] 4、synchronized和ReentrantLock的比较 Lock一个接口，提供ReentrantLock实现类，而synchronized是个关键字，是java内置线程同步。 synchronized在发生异常时，会自动的释放线程占用锁对象，不会导致死锁的现象发生，而Lock在发生异常时，如果没有主动的通过unLock方法释放锁对象，则可能会造成死锁的发生，因此在是使用Lock时需要在finally块中释放锁。 Lock可以让等待锁的线程中断，而synchronized则不行，会一直等待下去，直到有唤醒的操作。 Lock可以判断线程是否成功获取锁对象，而synchronized则不行。 总结： ReentrantLock和synchronized相比，主要是ReentrantLock实现类定义了一些特殊的方法，从而决定了ReentrantLock在功能上比synchronized更丰富些。但缺点也是，比如上述第二点，可以反映出在一定程度上synchronized安全性和使用便捷性上好些。 ReentrantLock中的一些方法： 1234567isFair() //判断锁是否是公平锁 isLocked() //判断锁是否被任何线程获取了 isHeldByCurrentThread() //判断锁是否被当前线程获取了 hasQueuedThreads() //判断是否有线程在等待该锁 性能比较 &ensp;&ensp;&ensp;&ensp;在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized 。所以说，在具体使用时要根据适当情况选择。 &ensp;&ensp;&ensp;&ensp;在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地， 所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步 。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"Synchronized","slug":"Synchronized","permalink":"http://yoursite.com/tags/Synchronized/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"慌得一匹！教大家如何应对在线故障！","slug":"慌得一匹！教大家如何应对在线故障！","date":"2019-01-10T06:09:51.000Z","updated":"2019-01-10T06:24:04.843Z","comments":true,"path":"2019/01/10/慌得一匹！教大家如何应对在线故障！/","link":"","permalink":"http://yoursite.com/2019/01/10/慌得一匹！教大家如何应对在线故障！/","excerpt":"","text":"线上运行的Java应用突然没有响应、响应缓慢，进程突然消失，遇到这些情况应该如何应对呢？ 来自公司内部分享","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"bug修复","slug":"bug修复","permalink":"http://yoursite.com/tags/bug修复/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"java分布式锁之redis实现篇","slug":"java分布式锁","date":"2019-01-09T08:03:11.000Z","updated":"2019-01-11T02:36:32.319Z","comments":true,"path":"2019/01/09/java分布式锁/","link":"","permalink":"http://yoursite.com/2019/01/09/java分布式锁/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;刚开始写这篇文章的时候其实我是拒绝的，因为我也是最近才接触这方面的知识点，实现技术本身也是雕虫小技，但是我还是觉得拿出来与大家一起分享，本着一个学习的态度吧，如果有大佬看到，请指点一二哈！ 1、前言&ensp;&ensp;&ensp;&ensp;由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，那么就要利用分布式锁来解决这些问题。所以将自己的心得体会记录下来做一个讲解和总结。希望这篇文章可以方便自己以后查阅，同时要是能帮助到刚开始接触到这方面的同学那也是很好的。 2、为什么要使用分布式锁&ensp;&ensp;&ensp;&ensp;关于分布式锁，可能绝大部分人都会或多或少涉及到。 我举二个例子：场景一：从前端界面发起一笔支付请求，如果前端没有做防重处理，那么可能在某一个时刻会有二笔一样的单子同时到达系统后台。场景二：在App中下订单的时候，点击确认之后，没反应，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。 在接收消息的时候，消息推送重复。如果处理消息的接口无法保证幂等，那么重复消费消息产生的影响可能会非常大。 &ensp;&ensp;&ensp;&ensp;为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 3、分布式锁应该具备的条件123456在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；高可用的获取锁与释放锁；高性能的获取锁与释放锁；具备可重入特性；具备锁失效机制，防止死锁；具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 4、基于redis的实现方式4.1、选择redis实现分布式锁的原因 Redis有很高的性能 Redis命令对此支持较好，实现起来比较方便 4.2、使用命令介绍（1）SETNX：SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。 （2）expire：expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 （3）delete：delete key：删除key 在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。 4.3、实现思想（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。 4.4、具体实现流程关于redis分布式锁的实现流程如下图所示： 注意：单个线程任务处理时间threadTime、获取锁的等待时间acquireTimeout、锁的过期时间timeout三者之间的关系： 1、threadTime &lt; timeout （不然会出错） 2、acquireTimeout &lt; threadTime &lt; timeout (一般标准的设置时间方法) 废话不多说，直接上代码： TestRedisLock类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TestRedisLock &#123; //redis分布式锁 public static void lock()&#123; String indentifier = null; RedisLock redisLock = null; try &#123; //toDO 增加分布式锁逻辑 redisLock = new RedisLock(RedisClient.jedisSentinelPool); //首次获取到锁是必然的 acquireTimeout 为获取锁的等待时间，如果超过此时间就放弃 timeout 为锁的过期时间 indentifier = redisLock.lockWithTimeout(\"ss_test\",3500, 3000); System.out.println(Thread.currentThread()+\"尝试获取锁,indentifier:\"+indentifier); ThreadLocal&lt;AtomicInteger&gt; threadLocal = new ThreadLocal(); threadLocal.set(new AtomicInteger(0)); while (indentifier == null)&#123;//一直请求锁，直到拿到为止 threadLocal.get().getAndIncrement(); indentifier = redisLock.lockWithTimeout(\"ss_test\",3500, 3000); //Thread.currentThread().sleep(100); System.out.println(Thread.currentThread()+\"尝试获取锁,indentifier:\"+indentifier+\"，第\"+threadLocal.get().get()+\"次\"); &#125; if(indentifier!=null)&#123; //拿到锁开始干活 System.out.println(Thread.currentThread()+\"获取到锁,indentifier:\"+indentifier); Thread.currentThread().sleep(4000); //System.out.println(1/0); //todo 执行任务 System.out.println(Thread.currentThread()+\"执行完成\"); &#125;else &#123; System.out.println(Thread.currentThread()+\"没有获取到锁\"); &#125; &#125; catch(Exception ex)&#123; ex.printStackTrace(); &#125; finally &#123; if(redisLock!=null &amp;&amp; StringUtils.isNotEmpty(indentifier))&#123; redisLock.releaseLock(\"ss_test\",indentifier); System.out.println(Thread.currentThread()+\"释放锁\"); &#125; &#125; &#125; //todo 线程锁 public static void main(String[] args) &#123; //模拟100人抢购 for (int i=0;i&lt;5;i++)&#123; Thread thread = new Thread()&#123; @Override public void run()&#123; lock(); &#125; &#125;; thread.start(); &#125; &#125;&#125; RedisLock类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class RedisLock &#123; private final JedisPool jedisPool; private static final Logger logger = Logger.getLogger(RedisLock.class); public RedisLock(JedisPool jedisPool) &#123; this.jedisPool = jedisPool; &#125; /** * * @param locaName 锁的key * @param acquireTimeout 尝试获取锁超时时间 * @param timeout key的超时时间 * @return 锁标识 */ public String lockWithTimeout(String locaName, long acquireTimeout, long timeout) &#123; Jedis conn = null; String retIdentifier = null; try &#123; // 获取连接 // 随机生成一个value String identifier = UUID.randomUUID().toString(); //如果identifier存在则成功获取到锁，否则表明该锁已经被其他线程占用 // 锁名，即key值 String lockKey = \"lock:\" + locaName; // 超时时间，上锁后超过此时间则自动释放锁 int lockExpire = (int)(timeout / 1000); conn = jedisPool.getResource(); // 获取锁的超时时间，超过这个时间则放弃获取锁 long end = System.currentTimeMillis() + acquireTimeout; while (System.currentTimeMillis() &lt; end) &#123; //Jedis conn = jedisPool.getResource(); //System.out.println(\"等待时间:\"+System.currentTimeMillis()); if (conn.setnx(lockKey, identifier) == 1) &#123; conn.expire(lockKey, lockExpire); // 返回value值，用于释放锁时间确认 retIdentifier = identifier; /*if (conn != null) &#123; conn.close(); //System.out.println(\"关闭连接\"); &#125;*/ return retIdentifier; &#125; // 返回-1代表key没有设置超时时间，为key设置一个超时时间 if (conn.ttl(lockKey) == -1) &#123; conn.expire(lockKey, lockExpire); &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); logger.error(\"RedisLock中断异常\",e); &#125; /* if (conn != null) &#123; conn.close(); //System.out.println(\"关闭连接\"); &#125;*/ &#125; &#125; catch (JedisException e) &#123; logger.error(\"RedisLock获取锁异常\",e); //jedisPool.returnBrokenResource(conn); &#125; finally &#123; if (conn != null) &#123; conn.close(); // System.out.println(\"关闭连接\"); &#125; &#125; return retIdentifier; &#125; /** * 释放锁 * @param lockName 锁的key * @param identifier 释放锁的标识 * @return */ public boolean releaseLock(String lockName, String identifier) &#123; Jedis conn = null; String lockKey = \"lock:\" + lockName; boolean retFlag = false; try &#123; conn = jedisPool.getResource(); while (true) &#123; // 监视lock，准备开始事务 conn.watch(lockKey); // 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁 if (identifier.equals(conn.get(lockKey))) &#123; Transaction transaction = conn.multi(); transaction.del(lockKey); List&lt;Object&gt; results = transaction.exec(); if (results == null) &#123; continue; &#125; retFlag = true; &#125; conn.unwatch(); break; &#125; &#125; catch (JedisException e) &#123; logger.error(\"RedisLock释放锁异常\",e); &#125; finally &#123; if (conn != null) &#123; conn.close(); &#125; &#125; return retFlag; &#125;&#125; 本次测试模拟五个线程，acquireTimeout = 2500， threadTime = 2700 ， timeout = 3000 实验结果如下： 5、小结&ensp;&ensp;&ensp;&ensp;在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。 当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"【深度好文】simhash文本去重流程","slug":"simhash","date":"2019-01-06T12:37:41.000Z","updated":"2019-01-10T05:52:50.672Z","comments":true,"path":"2019/01/06/simhash/","link":"","permalink":"http://yoursite.com/2019/01/06/simhash/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp;本人目前就职于某厂新闻客户端，对于新闻客户端而言，推荐的每一刷的新闻都必须是不同的新闻，这就需要对新闻文本进行排重。传统的去重一般是对文章的url链接进行排重，但是对于抓取的网页来说，各大平台的新闻可能存在重复，对于只通过文章url进行排重是不靠谱的，为了解决这个痛点于是就提出了用simhash来解决这个难题。 1.简介&ensp;&ensp;&ensp;&ensp;传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。即便是两个原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统的Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感hash，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 Detecting Near-Duplicates for Web Crawling 论文中所说），一般海明距离为3就代表两篇文章相同。&ensp;&ensp;&ensp;&ensp;simhash也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。 2.背景 如何设计一个比较两篇文章相似度的算法？可能你会回答几个比较传统点的思路: 一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离（可以计算它们之间的欧氏距离、海明距离或者夹角余弦等等），从而通过距离的大小来判断两篇文章的相似度。 另外一种是传统hash，我们考虑为每一个web文档通过hash的方式生成一个指纹（finger print）。 下面我们来分析一下这两种方法: 采取第一种方法，若是只比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度。你还会去计算任意两个网页之间的距离或夹角余弦么？那样做的话时间复杂度，空间复杂度可想而知。 而第二种方案中所说的传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化。 3.simhash与hash算法的区别&ensp;&ensp;&ensp;&ensp;传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。&ensp;&ensp;&ensp;&ensp;我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 4.simhash原理 simhash是google用来处理海量文本去重的算法。 google出品，你懂的。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是&lt;n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。 算法过程大致如下： 1，对文本分词，得到N维特征向量（默认为64维） 2，为分词设置权重（tf-idf） 3，为特征向量计算哈希 4，对所有特征向量加权，累加（目前仅进行非加权累加） 5，对累加结果，大于零置一，小于零置零 6，得到文本指纹（fingerprint） 具体流程实现 simhash的算法具体分为5个步骤：分词、hash、加权、合并、降维，具体过程如下： 分词 给定一段语句或者一段文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如给定一段语句：“生活本没有路，走的人多了就成了路，要相信阳光总在风雨后”，分词后结果为：生活 没有 成了 相信 阳光 风雨，然后为每个特征向量赋予权值：生活(5) 没有(2) 成了(1) 相信(2) 阳光(3) 风雨(2)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。 hash 通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“生活”的hash值Hash(生活)为110101，“没有”的hash值Hash(没有)为“101001”。就这样，字符串就变成了一系列数字。 加权 在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“生活”的hash值“110101”加权得到：W(生活) = 110101 5 = 5 5 -5 5 -5 5，给“没有”的hash值“101001”加权得到：W(没有)=101001 2 = 2 -2 2 -2 -2 2，其余特征向量类似此般操作。 合并 将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“生活”的“5 5 -5 5 -5 5”和“没有”的“2 -2 2 -2 -2 2”进行累加，得到“5+2 5-2 -5+2 5-2 -5-2 5+2”，得到“7 3 -3 3 -7 7”。 降维 对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 1 0 1 0 1”，从而形成它们的simhash签名。 整个过程的流程图为： 5、simhash的签名距离计算&ensp;&ensp;&ensp;&ensp;我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： 10101 和 00110 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。 &ensp;&ensp;&ensp;&ensp;我们可以把 64 位的二进制simhash签名均分成4块，每块16位。根据鸽巢原理（也称抽屉原理），如果两个签名的海明距离在 3 以内，它们必有一块完全相同。如下图所示： 6、simhash的存储和查找 我们需要将64位simhash均分为4份，然后每份作为key存储到redis 采用精确匹配的方式查找前16位 找到则拿出来计算与被比较的simahsh距离，小于3则判断为相似（当然具体问题具体分析，这个值可以调整） 如果样本库中存有2^34（差不多10亿）的哈希指纹，则每个table返回2^(34-16)=262144个候选结果，大大减少了海明距离的计算成本 7、聊聊Jaccard相似度与汉明距离7.1 Jaccard相似度&ensp;&ensp;&ensp;&ensp; Jaccard 系数，又叫Jaccard相似性系数，用来比较样本集中的相似性和分散性的一个概率。公式： 给定两个集合A,B jaccard 系数定义为A与B交集的大小与并集大小的比值，jaccard值越大说明相似度越高 7.2 汉明距离&ensp;&ensp;&ensp;&ensp;在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以d(x, y)表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串x变成y所需要的最小的替换次数。 12345举例说明以下字符串间的汉明距离为：&quot;karolin&quot; and &quot;kathrin&quot; is 3.&quot;karolin&quot; and &quot;kerstin&quot; is 3.1011101 and 1001001 is 2.2173896 and 2233796 is 3. 8、【实战】新闻文本去重服务详细流程&ensp;&ensp;&ensp;&ensp;上面陆陆续续讲了这么多理论知识想必大家也是一头雾水，接下来我们通过实战来讲述整体流程。 &ensp;&ensp;&ensp;&ensp;本文将文本排重做成了一个接口，首先给去重接口传一些必要的参数，针对新闻文本为例（url:链接 title:文本标题 content:内容）。依次是进行url排重、title排重、content排重，如果三种都没有找到，则建立url、title、content索引存储到redis。具体流程图如下： 8.1、URL排重 建立URL索引： 12key: url_index_name+&quot;_&quot;+urlMD5。url_index_name为索引名字，urlMD5表示url的MD5值value: docId+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，url表示新闻链接，storageTime表示存入redis的时间戳 根据urlMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.2、Title排重 建立Title索引： 12key: title_index_name+&quot;_&quot;+titleMD5。title_index_name为索引名字，titleMD5表示title的MD5值value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 根据titleMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。 8.3、Content排重 建立Content索引： 1234先将64位simhash值均分为4份：simHashFragment1、simHashFragment2、simHashFragment3、simHashFragment4key: content_index_name+&quot;_&quot;+simHashFragment。content_index_name为索引名字，simHashFragment表示其中一段simhash值（16位）value: docId+&quot;\\t&quot;+title+&quot;\\t&quot;+simhash+&quot;\\t&quot;+url+&quot;\\t&quot;+storageTime。 docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳 然后将这4份索引存储到redis(LIST) 根据simHashFragment索引从redis里面查找（4份simhash索引都得一起召回） 将召回的值依次与带排重的文本比对 hanmingDistance&lt;=H 并且 jarccardSimilary&gt;=J 召回(一般设置H=10,J=0.7 具体情况具体分析) 注：三天内新闻做法 hanmingDistance&lt;=3 并且 jarccardSimilary&gt;=0.7 注：三天外新闻做法 将召回的新闻做rank（这里不细讲，方法很多），TOP1作为排重的新闻 9、总结&ensp;&ensp;&ensp;&ensp;现如今是一个信息过载的时代，高效的从海量文本里面快速找到相似的文本是一个需要解决的一个痛点，simhash的存在就很好的解决了这个问题。 &ensp;&ensp;&ensp;&ensp;由于simhash是局部敏感的hash，其可能不适合做这种短标题的重复度判断，会存在一定的误差，文本越长判断的准确率越高。 好记性不如烂笔头，记录点滴！","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"文本去重","slug":"文本去重","permalink":"http://yoursite.com/tags/文本去重/"},{"name":"simhash","slug":"simhash","permalink":"http://yoursite.com/tags/simhash/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}]},{"title":"markdown基本语法","slug":"markdown基本语法","date":"2019-01-05T13:31:07.000Z","updated":"2019-01-08T10:05:38.100Z","comments":true,"path":"2019/01/05/markdown基本语法/","link":"","permalink":"http://yoursite.com/2019/01/05/markdown基本语法/","excerpt":"","text":"&ensp;&ensp;&ensp;&ensp; markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 优点 因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持markdown编辑模式。 一、标题&ensp;&ensp;&ensp;&ensp; 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三、引用在引用的文字前加&gt;即可。示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。示例： 12345-------******** 五、图片语法：123![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：12[搜狐](http://www.souhu.com)[百度](http://www.baidu.com) 七、列表无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 八、表格语法：1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例：12345| 水果 | 价格 | 数量 | | -------- | -----: | :----: | | 香蕉 | $1 | 5 | | 苹果 | $1 | 6 | | 草莓 | $1 | 7 | 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 九、代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容` python 代码块12345a = range(2000)for i in a: if i % 2 == 0: continue print(i + 1) java 代码块123456789private URLInfo extractURLHost(String url)&#123; URLInfo urlInfo = new URLInfo(); String host = HostDomainExtractKit.extractURLHost(url); String domain = HostDomainExtractKit.getTopLevelDomain(url); urlInfo.setHost(host); urlInfo.setDomain(domain); return urlInfo; &#125; 十、流程图一般写法：1234567st=&gt;start: Startop=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;Endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 注：MarkDown没 有统一标准，不同网站实现的方式不同，目前github上写markdown，并没有实现流程图的语法。","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}],"keywords":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}]},{"title":"ubuntu下安装PyV8","slug":"pyv8","date":"2019-01-03T15:42:15.000Z","updated":"2019-01-08T10:05:38.093Z","comments":true,"path":"2019/01/03/pyv8/","link":"","permalink":"http://yoursite.com/2019/01/03/pyv8/","excerpt":"","text":"这几天需要使用PyV8来进行python与javascript的交互，在ubuntu上面安装遇到了不少的坑，折腾几小时终于找到方法。 安装依赖123$ sudo apt-get install scons$ sudo apt-get install libboost-dev libboost-thread-dev$ sudo apt-get install libboost-system-dev libboost-python-dev 安装Pyv8&ensp;&ensp;&ensp;&ensp;下载二进制文件github找到适合你机器的版本下载。解压出来应该有两个文件：PyV8.py , _PyV8.so,然后把这两个文件拷贝到你的python第三方包的目录里面就好，比如我的是:12$ cd pyv8$ sudo cp * /usr/lib/python2.7/dist-packages/ &ensp;&ensp;&ensp;然后进入到python环境测试如下代码:123456789101112import PyV8ctxt = PyV8.JSContext()ctxt.enter()func = ctxt.eval(\"\"\"(function()&#123; function hello()&#123; return \"Hello world.\"; &#125; return hello(); &#125;) \"\"\")print func() 执行输出Hello World说明安装成功了，就可以模拟JS代码了。 好记性不如烂笔头，记录点滴！","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"pyv8","slug":"pyv8","permalink":"http://yoursite.com/tags/pyv8/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"hexo一个错误解","slug":"error","date":"2019-01-02T15:42:15.000Z","updated":"2019-01-08T10:05:38.107Z","comments":true,"path":"2019/01/02/error/","link":"","permalink":"http://yoursite.com/2019/01/02/error/","excerpt":"","text":"今天进入到博客目录，发现hexo命令行用不了了，报如下错误： ERROR Local hexo not found in ~/Downloads/hexo/blog ERROR Try running: ‘npm install hexo –save’ 解决办法 rm -rf node_modules npm install ok,至此hexo命令已经可以运行，问题解决！ 好记性不如烂笔头，记录点滴！","categories":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[{"name":"常见错误解决","slug":"常见错误解决","permalink":"http://yoursite.com/categories/常见错误解决/"}]},{"title":"smilemilk的第一次博客之旅","slug":"hello-world","date":"2019-01-01T01:42:15.000Z","updated":"2019-01-10T08:56:06.019Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/01/hello-world/","excerpt":"","text":"在这里我将会和大家在接下来的日子里面一起分享自己的爬虫+搜索+大数据方面的工程经验， &ensp;&ensp;&ensp;&ensp;本来2018年就想写点自己的东西一直拖到2019年（🤦捂脸。。。♀)，主要是因为2018年整个在忙实习还有硕士毕业的各种事情。转眼就到 2019 年了，其实我没有写总结的习惯，现在到头来还是蛮后悔的，说实话总结其实还是蛮有必要的，现在就趁着这个时间来立一下 2019 的 Flag，再等到 2020 年翻出来打脸吧，哈哈😄。 35岁之前只做能提高自己技术水平的事情，能够成为公认的某一个技术领域的专家。不随波逐流，要独树一帜。 优质博客： zsythink 崔庆才 rowkey 徐刘根 好记性不如烂笔头，接下来我的博客将会陆续更新，博客还在施工中，敬请期待！！","categories":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}],"tags":[],"keywords":[{"name":"about me","slug":"about-me","permalink":"http://yoursite.com/categories/about-me/"}]}]}
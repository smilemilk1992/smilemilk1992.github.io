<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>smilemilk</title>
  
  <subtitle>大数据 · Python · 技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-14T14:45:13.776Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chen Hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu server下搭建Maven私服Nexus</title>
    <link href="http://yoursite.com/2019/02/14/Ubuntu-server%E4%B8%8B%E6%90%AD%E5%BB%BAMaven%E7%A7%81%E6%9C%8DNexus/"/>
    <id>http://yoursite.com/2019/02/14/Ubuntu-server下搭建Maven私服Nexus/</id>
    <published>2019-02-14T14:22:19.000Z</published>
    <updated>2019-02-14T14:45:13.776Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu系统上，用nexus搭建maven私服</p><p><strong> 1.下载Nexus </strong></p><blockquote><p>wget -c <a href="http://download.sonatype.com/nexus/oss/nexus-2.10.0-02-bundle.tar.gz" target="_blank" rel="noopener">http://download.sonatype.com/nexus/oss/nexus-2.10.0-02-bundle.tar.gz</a></p></blockquote><p><strong> 2.启动Nexus </strong></p><blockquote><p>tar -zxvf nexus-2.10.0-02-bundle.tar.gz</p></blockquote><blockquote><p>cd /home/ubuntu/nexus/nexus-2.10.0-02/bin</p></blockquote><blockquote><p>./nexus start</p></blockquote><blockquote><p>启动成功，访问地址：<a href="http://ip:8081/nexus" target="_blank" rel="noopener">http://ip:8081/nexus</a></p></blockquote><p><strong> 3.配置nexus </strong></p><p>&ensp;&ensp;&ensp;&ensp;登录nexus，右上角Log In，默认登录用户名密码：admin/admin123</p><p><img src="/img/20190214/login.png" alt="知乎1"></p><p>关于仓库的类型介绍　　</p><p>hosted 类型的仓库，内部项目的发布仓库</p><p>releases 内部的模块中release模块的发布仓库</p><p>snapshots 发布内部的SNAPSHOT模块的仓库</p><p>3rd party 第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去</p><p>proxy 类型的仓库，从远程中央仓库中寻找数据的仓库</p><p>group 类型的仓库，组仓库用来方便我们开发人员进行设置的仓库</p><p><img src="/img/20190214/2.png" alt="知乎1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ubuntu系统上，用nexus搭建maven私服&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1.下载Nexus &lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wget -c &lt;a href=&quot;http://download.sonatype.com/nexus/oss
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="nexus" scheme="http://yoursite.com/tags/nexus/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>回首2018，展望2019</title>
    <link href="http://yoursite.com/2019/01/18/thksFor2018/"/>
    <id>http://yoursite.com/2019/01/18/thksFor2018/</id>
    <published>2019-01-18T03:44:02.000Z</published>
    <updated>2019-02-14T14:02:40.359Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2019.png" alt="2019"></p><p>&ensp;&ensp;&ensp;&ensp;回首2018，一句话总结自己：<strong>成就不算少，进步不算多。</strong></p><hr><h1 id="回首2018"><a href="#回首2018" class="headerlink" title="回首2018"></a>回首2018</h1><p>2018年是一个丰收的一年，这一年的轨迹如下：</p><p>（1）2018收到知乎 &amp; 搜狐的校招offer</p><p>（2）顺利地完成了毕业论文和毕业答辩</p><p>（3）4月入职搜狐，从当初的项目啥也不懂到现在的业务清晰</p><p>（4）2018年9月接到第一个大的私活（因为初入职场，本不想接，怕完成不了，最后还是接了，因为我对自己爬虫技术还是相当有信心的）</p><p>（5）迎娶白富美（瑶姐）~(ノへ￣、)捂脸</p><p>&ensp;&ensp;&ensp;&ensp;还有一些就不一一列举了，和一些大佬比起来，真的是小巫见大巫，不过对我本人来说真的是很有成就感了，可能就像常人说的那样“走上人生巅峰”，接下来列举比较重要和难忘的几个事情。</p><h2 id="知乎实习之旅"><a href="#知乎实习之旅" class="headerlink" title="知乎实习之旅"></a>知乎实习之旅</h2><p><img src="/img/知乎.jpg" alt="知乎1"></p><p><strong> 一、面试篇 </strong><br>&ensp;&ensp;&ensp;&ensp;我2017年9月初去的知乎面试，当时是地图导航过去的，对知乎的认知也仅仅局限于“知识社区”，我记得当时地图把我导到一个大的四合院里面，我当时就很纳闷，公司还可以在四合院的，与想象中的有点差距，接着我联系到了HR，我依然记得当时的一面面试官（电轻老师），长得真的很像李晨，问的问题我基本上都能回答的上，面试官话不多，比较害羞（程序员好像都这样吧哈哈），紧接着我被安排二面，二面的就是我当时的老大（雨舟老师），言语非常犀利，问的问题特别多，我记得有一个业务场景题，要求现场手写代码实现，我这个题足足想了20分钟，最后才做对一半，但是老大安慰我说：“嗯可以，思路还行，就是少考虑了一方面”，接着就问我啥时候可以到岗，我说任何时候，老大点了点头离开了。我当时以为没戏了等了半天HR还没来谈最后的offer，我当时觉得没戏了就直接回去了，等到快到地铁的时候，接到了老大打来的电话：“你人呢，咋面试完就跑啦，快回来，HR和你谈一下薪资”，我当时激动的语无伦次呀，于是骑着摩拜一路狂奔到公司，HR正好在公司门口等我，接着开始了我最喜欢的谈话，就是谈薪酬。</p><pre><code class="bash">HR：面试官反馈你的业务水平还不错，被录取了。我：哦哦（很淡定，其实内心已经飘了）HR：你在上一家公司实习工资多少？我：一天250（注：一个月下来5000多一点点，不包吃）HR：那这样我们给你一个月6000，配mac，公司包早中晚三餐我：好 （内心欣喜若狂，但是后来我觉得我应该谈多一点的，太保守了，哎！）</code></pre><p>&ensp;&ensp;&ensp;&ensp;哎在回家的路上我即欣喜又后悔，我后悔谈少了，别人家HR那么爽快，我应该多说一点的，但是作为实习生来讲确实觉得6000+mac标配+三餐很诱人。</p><p><strong> 二、入职篇 </strong></p><p>&ensp;&ensp;&ensp;&ensp;我记得是9月13入职知乎，被HR安排到工位后，老大开始带着我一个个相互认识，介绍完后，我开始折腾公司给 配备的mac电脑，说实话之前一直用的windows系统的电脑，mac还真的玩不转，折腾半天最后问了老大这个系统咋用（当时真的很尴尬，就不说了），好在老大耐心教我怎么用这个系统。<br>&ensp;&ensp;&ensp;&ensp;系统环境各方面安装好后，老大开始给我布置接下来的任务，让我写一个技术实现文档，第二天做一个技术报告评审，我想着这简单，于是就做了一些准备，第二天的技术评审是我第一次以实习生的身份在众多大佬面前做的报告，刚开始有点紧张到后面就适应了，主要是技术实现方案的讲述，后面组里的前辈也给一些改进方案，就这样第一次报告会圆满结束。</p><p><strong> 三、知乎实习感悟篇 </strong></p><p>&ensp;&ensp;&ensp;&ensp;我这边做的一个项目就是竞品分析，涉及到文本排重（当时选用的simhash来做），这里不做过多介绍，项目保密嘿嘿！此处省略1000字。在实习的过程当中，遇到了一些良师，比如雨舟老师、电轻老师、小崔老师、超强老师、志心哥等。</p><p>&ensp;&ensp;&ensp;&ensp;雨舟老师，我们组老大，91年，人非常幽默，我总感觉和王祖蓝真的一模一样，不过91年能当老大，我真的很佩服，啥都懂，情商、智商双高，总是带我们讲段子，动不动就发车，猝不及防。</p><p>&ensp;&ensp;&ensp;&ensp;电轻老师，知乎元老级人物，创始人之一，是我当时的同桌，人比较内向，不喜欢讲话，但是技术，人没的说，很照顾我，给了我很多技术方面的支持。</p><p>&ensp;&ensp;&ensp;&ensp;小崔老师，知乎三年元老级人物，研究生毕业就待在知乎，可谓是看着知乎逐渐壮大，人特别幽默，有违和感，也带过我。</p><p>&ensp;&ensp;&ensp;&ensp;以上带过我的老师就介绍这么多吧，真的很感恩遇见，我记得当时我像雨舟老师提出离职的时候，他竭力劝我留下来，说我在里面沉淀2年，各方面都会有很大的突破，当时我一心想去搜狐（主要是搜狐的工资给到位了），哎想想自己当时太现实了，面向工资编程。电轻老师也拉着我到操场谈心，还给我买了一瓶营养快线，说实话我真的很感动，他说没有好好带我，本来刚开始想带我一起做一个项目，但是最后因为一些事情吧就没有实施，我当时那个感动，晚上电轻老师开车把我送到家，果然电轻老师是土豪，哈哈开着捷豹上下班，一路上我们聊了很多，，，真的感恩相遇。</p><p>&ensp;&ensp;&ensp;&ensp;知乎友好的团队氛围真的感染了我，时至今日我都还想这自己可以以后有朝一日可以在和他们一起共事，我想以后也没有机会了，既然选择了搜狐就好好干吧，把自己手头的事情做到尽善尽美，完善自己的技术。</p><h2 id="读研感悟篇"><a href="#读研感悟篇" class="headerlink" title="读研感悟篇"></a>读研感悟篇</h2><p><img src="/img/实验室图片.jpeg" alt="实验室"></p><p>&ensp;&ensp;&ensp;&ensp;18年5月18日是研究生毕业答辩的日子，依稀记得我的论文从最初的论文目录选定到最终论文定稿都是在马老师严格要求下完成，我的导师马老师是一位认真负责的老师，对待学术科研非常严谨。时光飞逝，三年时光转瞬即逝，恍如昨日。还记得2015年我考上研究生的那份喜悦，到现如今即将踏上社会的忐忑，其实三年的时间不长也不短，研究生的学习生涯开阔了我的视野，磨练了我的意志，同时也学会了以严谨、认真的态度来做科研，以平和的心态来面对学习生活中的挑战。短暂的三年有太多值得珍藏的回忆，在这里收获了满满的友情以及师生之情，正是有了你们的关心和支持，纵使前方道路充满坎坷，我也无所畏惧，勇往直前。</p><p>&ensp;&ensp;&ensp;&ensp;首先，我要真诚的感谢我的导师马娅婕老师。马老师即是良师也是亦友，在学术上面认真严谨，精益求精，在工作中一丝不苟，在生活中朴实无华，平易近人。在三年的研究生学习生涯中，马老师深入引导我们研究当前学习内容，端正了我们的学习态度，当我在学习中遇到困难时又孜孜不倦的提供具有建设性意见的解决方案，在生活中督促大家劳逸结合，提高科研效率。在毕业设计的整个过程中，从论文题目的选取、论文的开题、论文提纲的设计以及最终的撰写的过程中，马老师都给予了我细心的指导以及无私的帮助，并且给出的针对性的建议，整个论文才得以顺利完成。</p><p>&ensp;&ensp;&ensp;&ensp;其次，非常感谢我的家人以及朋友，在我求学的过程当中他们给予了我鼓励以及莫大的支持，这才使的我能够全心的投入到我的学业，认真学习科学文化知识。</p><h2 id="迎娶白富美"><a href="#迎娶白富美" class="headerlink" title="迎娶白富美"></a>迎娶白富美</h2><p>&ensp;&ensp;&ensp;&ensp;2019年2月2号那天我迎娶了这个世界上最美丽的妻子，从此我将要为了我们幸福生活而努力！我说过我不能让你成为世界上最富有的女人，但是我会让你成为世界上最幸福的女人。</p><h1 id="展望2019"><a href="#展望2019" class="headerlink" title="展望2019"></a>展望2019</h1><p>2019年给自己定几个小目标：</p><blockquote><p>2019年努力提升自己的技术</p></blockquote><blockquote><p>2019年结交一些的志同道合的朋友</p></blockquote><blockquote><p>2019年买套房 （划重点）</p></blockquote><blockquote><p>…….</p></blockquote><p><img src="/img/头图1.jpeg" alt="头图1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/2019.png&quot; alt=&quot;2019&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;回首2018，一句话总结自己：&lt;strong&gt;成就不算少，进步不算多。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;回首2018&quot;
      
    
    </summary>
    
      <category term="about me" scheme="http://yoursite.com/categories/about-me/"/>
    
    
  </entry>
  
  <entry>
    <title>一张图学会Vim编辑器快捷键</title>
    <link href="http://yoursite.com/2019/01/16/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9AVim%E7%BC%96%E8%BE%91%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/01/16/一张图学会Vim编辑器快捷键/</id>
    <published>2019-01-16T10:26:47.000Z</published>
    <updated>2019-01-16T10:35:06.174Z</updated>
    
    <content type="html"><![CDATA[<p><strong> vim是一个平时非常实用的工具，在这里记录一下。 </strong></p><p><strong> Vim使用快捷键组合 </strong></p><p><img src="/img/20190116/头图4.jpg" alt="头图"></p><p><strong> Vim键盘图 </strong></p><p><img src="/img/20190116/头图3.png" alt="头图"></p><h1 id="1、移动光标"><a href="#1、移动光标" class="headerlink" title="1、移动光标"></a>1、移动光标</h1><p>1、左移h、右移l、下移j、上移k</p><p>2、向下翻页ctrl + f，向上翻页ctrl + b</p><p>3、向下翻半页ctrl + d，向上翻半页ctrl + u</p><p>4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^</p><p>5、移动光标到下一个句子 ），移动光标到上一个句子（</p><p>6、移动到段首{，移动到段尾}</p><p>7、移动到下一个词w，移动到上一个词b</p><p>8、移动到文档开始gg，移动到文档结束G</p><p>9、移动到匹配的{}.().[]处%</p><p>10、跳到第n行 ngg 或 nG 或 :n</p><p>11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L</p><p>12、读取当前字符，并移动到本屏幕内下一次出现的地方 *</p><p>13、读取当前字符，并移动到本屏幕内上一次出现的地方 #</p><h1 id="2、替换查找"><a href="#2、替换查找" class="headerlink" title="2、替换查找"></a>2、替换查找</h1><p>1、光标向后查找关键字 #或者g#</p><p>2、光标向前查找关键字<em> 或者g</em></p><p>3、当前行查找字符 fx, Fx, tx, Tx</p><p>4、基本替换 :s/s1/s2 （将下一个s1替换为s2）</p><p>5、全部替换 :%s/s1/s2</p><p>6、只替换当前行 :s/s1/s2/g</p><p>7、替换某些行 :n1,n2 s/s1/s2/g</p><p>8、搜索模式为 /string，搜索下一处为n，搜索上一处为N</p><p>9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母</p><p>10、移动到某标签处 `x，1旁边的键</p><p>11、移动到上次编辑文件的位置</p><h1 id="3、编辑操作"><a href="#3、编辑操作" class="headerlink" title="3、编辑操作"></a>3、编辑操作</h1><p>1、光标后插入a, 行尾插入A</p><p>2、后插一行插入o，前插一行插入O</p><p>3、删除字符插入s， 删除正行插入S</p><p>4、光标前插入i，行首插入I</p><p>5、删除一行dd，删除后进入插入模式cc或者S</p><p>6、删除一个单词dw，删除一个单词进入插入模式cw</p><p>7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl</p><p>8、粘贴p，交换两个字符xp，交换两行ddp</p><p>9、复制y，复制一行yy</p><p>10、撤销u，重做ctrl + r，重复.</p><p>11、智能提示 ctrl + n 或者 ctrl + p</p><p>12、删除motion跨过的字符，删除并进入插入模式 c{motion}</p><p>13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx</p><p>14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx</p><p>15、删除motion跨过的字符，删除但不进入插入模式 d{motion}</p><p>16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx</p><p>17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx</p><p>18、如果只是复制的情况时，将12-17条中的c或d改为y</p><p>19、删除到行尾可以使用D或C</p><p>20、拷贝当前行 yy或者Y</p><p>21、删除当前字符 x</p><p>22、粘贴 p</p><p>23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy</p><p>24、重复执行上一个作用使用.</p><p>25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行</p><p>26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进</p><p>27、 &gt;&gt; 缩进所有选择的代码</p><p>28、 &lt;&lt; 反缩进所有选择的代码</p><p>29、gd 移动到光标所处的函数或变量的定义处</p><p>30、K 在man里搜索光标所在的词</p><p>31、合并两行 J</p><p>32、若不想保存文件，而重新打开 :e!</p><p>33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换</p><h1 id="4、窗口操作"><a href="#4、窗口操作" class="headerlink" title="4、窗口操作"></a>4、窗口操作</h1><p>1、分隔一个窗口:split或者:vsplit</p><p>2、创建一个窗口:new或者:vnew</p><p>3、在新窗口打开文件:sf {filename}</p><p>4、关闭当前窗口:close</p><p>5、仅保留当前窗口:only</p><p>6、到左边窗口 ctrl + w, h</p><p>7、到右边窗口 ctrl + w, l</p><p>8、到上边窗口 ctrl + w, k</p><p>9、到下边窗口 ctrl + w, j</p><p>10、到顶部窗口 ctrl + w, t</p><p>11、到底部窗口 ctrl + w, b</p><h1 id="5、宏操作"><a href="#5、宏操作" class="headerlink" title="5、宏操作"></a>5、宏操作</h1><p>1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中</p><p>2、@[a-z]执行寄存器[a-z]中的操作</p><p>3、@@执行最近一次记录的宏操作</p><h1 id="6、可视操作"><a href="#6、可视操作" class="headerlink" title="6、可视操作"></a>6、可视操作</h1><p>1、进入块可视模式 ctrl + v</p><p>2、进入字符可视模式 v</p><p>3、进入行可视模式 V</p><p>4、删除选定的块 d</p><p>5、删除选定的块然后进入插入模式 c</p><p>6、在选中的块同是插入相同的字符 I<string>ESC</string></p><h1 id="7、跳到声明"><a href="#7、跳到声明" class="headerlink" title="7、跳到声明"></a>7、跳到声明</h1><p>1、[[ 向前跳到顶格第一个{  </p><p>2、[] 向前跳到顶格第一个}</p><p>3、]] 向后跳到顶格的第一个{</p><p>4、]] 向后跳到顶格的第一个}</p><p>5、[{ 跳到本代码块的开头</p><p>6、]} 跳到本代码块的结尾</p><h1 id="8、挂起操作"><a href="#8、挂起操作" class="headerlink" title="8、挂起操作"></a>8、挂起操作</h1><p>1、挂起Vim ctrl + z 或者 :suspend</p><p>2、查看任务 在shell中输入 jobs</p><p>3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）</p><p>4、执行shell命令 :!command</p><p>5、开启shell命令 :shell，退出该shell exit</p><p>6、保存vim状态 :mksession name.vim</p><p>7、恢复vim状态 :source name.vim</p><p>8、启动vim时恢复状态 vim -S name.vim</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; vim是一个平时非常实用的工具，在这里记录一下。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Vim使用快捷键组合 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/20190116/头图4.jpg&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程-ReentrantReadWriteLock</title>
    <link href="http://yoursite.com/2019/01/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-ReentrantReadWriteLock/"/>
    <id>http://yoursite.com/2019/01/16/Java多线程编程-ReentrantReadWriteLock/</id>
    <published>2019-01-16T08:04:50.000Z</published>
    <updated>2019-01-16T09:49:02.801Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/20190116/头图2.png" alt="头图"></p><p>&ensp;&ensp;&ensp;&ensp;上一篇已经介绍了synchronized与ReentrantLock这两种加锁模式，接下来介绍一下读写锁ReentrantReadWriteLock。</p><p>&ensp;&ensp;&ensp;&ensp;设想以下情景：我们在系统中有一个多线程访问的缓存，多个线程都可以对缓存进行读或写操作，但是读操作远远多于写操作，要求写操作要线程安全，且写操作执行完成要求对当前的所有读操作马上可见。<br>                        分析上面的需求：因为有多个线程可能会执行写操作，因此多个线程的写操作必须同步串行执行；而写操作执行完成要求对当前的所有读操作马上可见，这就意味着当有线程正在读的时候，要阻塞写操作，当正在执行写操作时，要阻塞读操作。一个简单的实现就是将数据直接加上互斥锁，同一时刻不管是读还是写线程，都只能有一个线程操作数据。但是这样的问题就是如果当前只有N个读线程，没有写线程，这N个读线程也要傻呵呵的排队读，尽管其实是可以安全并发提高效率的。<br>&ensp;&ensp;&ensp;&ensp;因此理想的实现是：<br>（1）当有写线程时，则写线程独占同步状态。<br>（2）当没有写线程时只有读线程时，则多个读线程可以共享同步状态。<br>读写锁就是为了实现这种效果而生。</p><hr><h1 id="1、使用示例"><a href="#1、使用示例" class="headerlink" title="1、使用示例"></a>1、使用示例</h1><h2 id="1-1-读读共享"><a href="#1-1-读读共享" class="headerlink" title="1.1 读读共享"></a>1.1 读读共享</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"已经读取到了 "</span> +Thread.currentThread().getName()+<span class="string">" "</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Lock lock=<span class="keyword">new</span> Lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Lock()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    lock.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 运行结果： </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已经读取到了 Thread-1 1547626862703</span><br><span class="line">已经读取到了 Thread-2 1547626862704</span><br><span class="line">已经读取到了 Thread-3 1547626862704</span><br><span class="line">已经读取到了 Thread-4 1547626862704</span><br><span class="line">已经读取到了 Thread-5 1547626862704</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看出两个线程之间，获取锁的时间几乎同时，说明lock.readLock().lock(); 允许多个线程同时执行lock（）方法后面的代码。</p><h2 id="1-2-写写互斥"><a href="#1-2-写写互斥" class="headerlink" title="1.2 写写互斥"></a>1.2 写写互斥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"已经读取到了 "</span> +Thread.currentThread().getName()+<span class="string">" "</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Lock lock=<span class="keyword">new</span> Lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Lock()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    lock.write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 运行结果： </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已经读取到了 Thread-1 1547627124841</span><br><span class="line">已经读取到了 Thread-2 1547627125345</span><br><span class="line">已经读取到了 Thread-3 1547627125846</span><br><span class="line">已经读取到了 Thread-4 1547627126351</span><br><span class="line">已经读取到了 Thread-5 1547627126851</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看出执行结果大致差了500ms的时间，可以说明多个写线程是互斥的。</p><h2 id="1-3-读写互斥或者写读互斥"><a href="#1-3-读写互斥或者写读互斥" class="headerlink" title="1.3 读写互斥或者写读互斥"></a>1.3 读写互斥或者写读互斥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"已经读取到了 "</span> +Thread.currentThread().getName()+<span class="string">" "</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"已经写入到了 "</span> +Thread.currentThread().getName()+ <span class="string">" "</span>+System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Lock lock=<span class="keyword">new</span> Lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Lock()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    lock.write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Lock()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    lock.read();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 运行结果： </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">已经写入到了 Thread-1 1547627278293</span><br><span class="line">已经写入到了 Thread-2 1547627279297</span><br><span class="line">已经写入到了 Thread-3 1547627280300</span><br><span class="line">已经写入到了 Thread-4 1547627281303</span><br><span class="line">已经写入到了 Thread-5 1547627282307</span><br><span class="line">已经读取到了 Thread-6 1547627283312</span><br><span class="line">已经读取到了 Thread-7 1547627283312</span><br><span class="line">已经读取到了 Thread-8 1547627283313</span><br><span class="line">已经读取到了 Thread-9 1547627283313</span><br><span class="line">已经读取到了 Thread-10 1547627283313</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看出先执行了写操作，然后执行读操作，写操作之间是互斥的，读操作共享的，读与写这两个动作互斥的。</p><h1 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h1><p> 多个线程可以同时进入同一个读锁</p><p> 多个线程不能同时进入同一个写锁</p><p> 多个线程不能同时进入同一对读锁、写锁</p><p> 一个线程可以先进入写锁、再进入读锁</p><p> 一个线程可以先进入写锁、再进入读锁、再进入写锁</p><p> 一个线程可以先进入读锁、再进入写锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/20190116/头图2.png&quot; alt=&quot;头图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;上一篇已经介绍了synchronized与ReentrantLock这两种加锁模式，接下来介绍一下读写锁ReentrantRe
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="ReentrantReadWriteLock" scheme="http://yoursite.com/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程-synchronized与ReentrantLock</title>
    <link href="http://yoursite.com/2019/01/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-1/"/>
    <id>http://yoursite.com/2019/01/11/Java多线程编程-1/</id>
    <published>2019-01-11T08:52:36.000Z</published>
    <updated>2019-01-16T08:57:45.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、进程与线程的概念"><a href="#1、进程与线程的概念" class="headerlink" title="1、进程与线程的概念"></a>1、进程与线程的概念</h1><p>（1）在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单位都是进程。<br>   在未配置 OS 的系统中，程序的执行方式是顺序执行，即必须在一个程序执行完后，才允许另一个程序执行；在多道程序环境下，则允许多个程序并发执行。程序的这两种执行方式间有着显著的不同。也正是程序并发执行时的这种特征，才导致了在操作系统中引入进程的概念。<br>   自从在 20 世纪 60 年代人们提出了进程的概念后，在 OS 中一直都是以进程作为能拥有资源和独立运行的基本单位的。直到 20 世纪 80 年代中期，人们又提出了比进程更小的能独立运行的基本单位——线程(Thread)，试图用它来提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量。特别是在进入 20 世纪 90 年代后，多处理机系统得到迅速发展，线程能比进程更好地提高程序的并行执行程度，充分地发挥多处理机的优越性，因而在近几年所推出的多处理机OS中也都引入了线程，以改善OS的性能。</p><p>   —–以上摘自《计算机操作系统-汤小丹等编著-3 版》</p><p>（2）进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>（3）线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p><p>进程与线程的关系如下图所示：</p><p><img src="/img/20190111/进程线程.jpg" alt="进程与线程关系"></p><h1 id="2、Java实现多线程的方式"><a href="#2、Java实现多线程的方式" class="headerlink" title="2、Java实现多线程的方式"></a>2、Java实现多线程的方式</h1><h2 id="2-1、继承Thread，重写run（）方法"><a href="#2-1、继承Thread，重写run（）方法" class="headerlink" title="2.1、继承Thread，重写run（）方法"></a>2.1、继承Thread，重写run（）方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程名字："</span>+currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p> 线程名字：Thread-0</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;另外，要明白启动线程的是start（）方法而不是run（）方法，如果用run（）方法，那么他就是一个普通的方法执行了。</p><h2 id="2-2、实现Runable接口"><a href="#2-2、实现Runable接口" class="headerlink" title="2.2、实现Runable接口"></a>2.2、实现Runable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"线程任务"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">       Thread thread = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">       thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、线程安全"><a href="#3、线程安全" class="headerlink" title="3、线程安全"></a>3、线程安全</h1><p>&ensp;&ensp;&ensp;&ensp;线程安全概念：当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</p><p>&ensp;&ensp;&ensp;&ensp;线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。这里的加锁机制常见的如：synchronized </p><h2 id="3-1、synchronized修饰符"><a href="#3-1、synchronized修饰符" class="headerlink" title="3.1、synchronized修饰符"></a>3.1、synchronized修饰符</h2><p>&ensp;&ensp;&ensp;&ensp; 在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。<br>&ensp;&ensp;&ensp;&ensp; synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。<br>我们接下来模拟火车站抢票的流程：<br>（1）Runable接口加锁实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">    ReentrantLock rt=<span class="keyword">new</span> ReentrantLock();  <span class="comment">//第三种方法，显示加锁，效率最高</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//防止出现线程安全的问题</span></span><br><span class="line">            ticket--;</span><br><span class="line">            System.out.println(<span class="string">"剩余"</span>+ticket+<span class="string">"张票"</span>+<span class="string">" "</span>+Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========开始卖票!========="</span>);</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//模拟10个人抢票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread=<span class="keyword">new</span> Thread(myRunnable,String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们模拟开启10个线程开始抢票，其实现结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">剩余9张票 Thread[0,5,main]</span><br><span class="line">剩余8张票 Thread[1,5,main]</span><br><span class="line">剩余7张票 Thread[2,5,main]</span><br><span class="line">剩余6张票 Thread[3,5,main]</span><br><span class="line">剩余5张票 Thread[4,5,main]</span><br><span class="line">剩余4张票 Thread[5,5,main]</span><br><span class="line">剩余3张票 Thread[6,5,main]</span><br><span class="line">剩余2张票 Thread[7,5,main]</span><br><span class="line">剩余1张票 Thread[8,5,main]</span><br><span class="line">剩余0张票 Thread[9,5,main]</span><br></pre></td></tr></table></figure></p><p>我们来看一下不加锁（synchronized）的情况:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">剩余8张票 Thread[1,5,main]</span><br><span class="line">剩余8张票 Thread[0,5,main]</span><br><span class="line">剩余7张票 Thread[2,5,main]</span><br><span class="line">剩余6张票 Thread[3,5,main]</span><br><span class="line">剩余5张票 Thread[4,5,main]</span><br><span class="line">剩余4张票 Thread[5,5,main]</span><br><span class="line">剩余3张票 Thread[6,5,main]</span><br><span class="line">剩余2张票 Thread[7,5,main]</span><br><span class="line">剩余1张票 Thread[8,5,main]</span><br><span class="line">剩余0张票 Thread[9,5,main]</span><br></pre></td></tr></table></figure></p><p>通过上面运行的结果可以看到不加锁(synchronized)的时候，出现线程不安全的问题。</p><p>(2)继承Thread实现方法(加锁synchronized)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class) &#123; <span class="comment">//防止出现线程安全的问题</span></span><br><span class="line">            ticket--;</span><br><span class="line">            System.out.println(<span class="string">"剩余"</span> + ticket + <span class="string">"张票"</span> + <span class="string">" "</span> + currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//开10个人进行抢票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            MyThread thread = <span class="keyword">new</span> MyThread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    getTicket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明：</p><blockquote><p>当多个线程访问MyThread 的run方法的时候，如果使用了synchronized修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行synchronized修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行synchronized代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。</p></blockquote><h2 id="3-2、ReentrantLock锁的实现方案"><a href="#3-2、ReentrantLock锁的实现方案" class="headerlink" title="3.2、ReentrantLock锁的实现方案"></a>3.2、ReentrantLock锁的实现方案</h2><p>&ensp;&ensp;&ensp;&ensp;在java 5之前，一直靠synchronized关键字来实现锁功能的，处理多线程并发的问题；而在java 5之后新增了Lock接口来实现锁的功能，同时也Lock接口提供ReentrantLock实现类（可重入锁）。</p><p>&ensp;&ensp;&ensp;&ensp;与synchronized关键字相比，ReentrantLock使用时需要显式的获取或释放锁，而synchronized可以隐式获取和释放锁，也就是说，在正常使用情况下，ReentrantLock需要手动操作锁的获取和释放，synchronized可以自动的获取和释放，从操作性上synchronized是相对便捷的，居然ReentrantLock是手动的，那么也有它的优势，就是可以自定义一些其他的操作，比如中断锁的获取及超时获取锁等多种特性。</p><p><strong> 下面是关于Lock接口一些主要方法： </strong></p><ul><li><p>void lock(): 执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。</p></li><li><p>boolean tryLock()： 如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是”试图”获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码。而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法。</p></li><li><p>void unlock()： 执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生。</p></li><li><p>Condition newCondition()： 条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。</p></li></ul><p>ReentrantLock的使用并不复杂，通常是加锁（获取锁）、释放同步锁即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//定义需要保证的线程安全的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//获取锁，加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要保证线程安全的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//使用finally来保证锁的释放</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;这一结构确保任何时刻只有一个线程进入临界区（临界区是指共享资源的代码区），一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们则被阻塞直到第一个线程释放锁对象。把解锁的操作放在finally中是十分必要的，如果在临界区发生了异常，锁是必须要释放的，否则其他线程将会永远阻塞。</p><p>使用ReentrantLock锁解决线程同步问题</p><p>针对上面买票的问题，下面可重入锁（ReentrantLock）解决:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;</span><br><span class="line">    ReentrantLock rt=<span class="keyword">new</span> ReentrantLock();  <span class="comment">//第三种方法，显示加锁，效率最高</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rt.lock();   <span class="comment">//加锁</span></span><br><span class="line">            ticket--;</span><br><span class="line">            System.out.println(<span class="string">"剩余"</span>+ticket+<span class="string">"张票"</span>+<span class="string">" "</span>+Thread.currentThread());</span><br><span class="line">        rt.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=========开始卖票!========="</span>);</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//开10个线程消费抢票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            thread=<span class="keyword">new</span> Thread(myRunnable,String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=========开始卖票!=========</span><br><span class="line">剩余9张票 Thread[0,5,main]</span><br><span class="line">剩余8张票 Thread[3,5,main]</span><br><span class="line">剩余7张票 Thread[4,5,main]</span><br><span class="line">剩余6张票 Thread[6,5,main]</span><br><span class="line">剩余5张票 Thread[1,5,main]</span><br><span class="line">剩余4张票 Thread[7,5,main]</span><br><span class="line">剩余3张票 Thread[8,5,main]</span><br><span class="line">剩余2张票 Thread[2,5,main]</span><br><span class="line">剩余1张票 Thread[5,5,main]</span><br><span class="line">剩余0张票 Thread[9,5,main]</span><br></pre></td></tr></table></figure></p><h1 id="4、synchronized和ReentrantLock的比较"><a href="#4、synchronized和ReentrantLock的比较" class="headerlink" title="4、synchronized和ReentrantLock的比较"></a>4、synchronized和ReentrantLock的比较</h1><ul><li>Lock一个接口，提供ReentrantLock实现类，而synchronized是个关键字，是java内置线程同步。</li><li>synchronized在发生异常时，会自动的释放线程占用锁对象，不会导致死锁的现象发生，而Lock在发生异常时，如果没有主动的通过unLock方法释放锁对象，则可能会造成死锁的发生，因此在是使用Lock时需要在finally块中释放锁。</li><li>Lock可以让等待锁的线程中断，而synchronized则不行，会一直等待下去，直到有唤醒的操作。</li><li>Lock可以判断线程是否成功获取锁对象，而synchronized则不行。</li></ul><p>总结：</p><blockquote><p>ReentrantLock和synchronized相比，主要是ReentrantLock实现类定义了一些特殊的方法，从而决定了ReentrantLock在功能上比synchronized更丰富些。但缺点也是，比如上述第二点，可以反映出在一定程度上synchronized安全性和使用便捷性上好些。</p></blockquote><p><strong> ReentrantLock中的一些方法： </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isFair()      //判断锁是否是公平锁</span><br><span class="line"> </span><br><span class="line">isLocked()    //判断锁是否被任何线程获取了</span><br><span class="line"> </span><br><span class="line">isHeldByCurrentThread()   //判断锁是否被当前线程获取了</span><br><span class="line"> </span><br><span class="line">hasQueuedThreads()   //判断是否有线程在等待该锁</span><br></pre></td></tr></table></figure></p><p><strong> 性能比较 </strong></p><p>&ensp;&ensp;&ensp;&ensp;在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而<strong> 当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized </strong>。所以说，在具体使用时要根据适当情况选择。</p><p>&ensp;&ensp;&ensp;&ensp;在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，<strong> 所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步 </strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、进程与线程的概念&quot;&gt;&lt;a href=&quot;#1、进程与线程的概念&quot; class=&quot;headerlink&quot; title=&quot;1、进程与线程的概念&quot;&gt;&lt;/a&gt;1、进程与线程的概念&lt;/h1&gt;&lt;p&gt;（1）在传统的操作系统中，程序并不能独立运行，作为资源分配和独立运行的基本单
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Synchronized" scheme="http://yoursite.com/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>慌得一匹！教大家如何应对在线故障！</title>
    <link href="http://yoursite.com/2019/01/10/%E6%85%8C%E5%BE%97%E4%B8%80%E5%8C%B9%EF%BC%81%E6%95%99%E5%A4%A7%E5%AE%B6%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%9C%A8%E7%BA%BF%E6%95%85%E9%9A%9C%EF%BC%81/"/>
    <id>http://yoursite.com/2019/01/10/慌得一匹！教大家如何应对在线故障！/</id>
    <published>2019-01-10T06:09:51.000Z</published>
    <updated>2019-01-10T06:24:04.843Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/20190110/1.png" alt="bug1"></p><hr><p>线上运行的Java应用突然没有响应、响应缓慢，进程突然消失，遇到这些情况应该如何应对呢？</p><p>来自公司内部分享</p><p><img src="/img/20190110/arch-2.jpeg" alt="bug2"></p><p><img src="/img/20190110/arch-3.jpeg" alt="bug3"></p><p><img src="/img/20190110/arch-4.jpeg" alt="bug4"></p><p><img src="/img/20190110/arch-5.jpeg" alt="bug5"></p><p><img src="/img/20190110/arch-6.jpeg" alt="bug6"></p><p><img src="/img/20190110/arch-7.jpeg" alt="bug7"></p><p><img src="/img/20190110/arch-8.jpeg" alt="bug8"></p><p><img src="/img/20190110/arch-9.jpeg" alt="bug9"></p><p><img src="/img/20190110/arch-10.jpeg" alt="bug10"></p><p><img src="/img/20190110/arch-11.jpeg" alt="bug11"></p><p><img src="/img/20190110/arch-12.jpeg" alt="bug12"></p><p><img src="/img/20190110/arch-13.jpeg" alt="bug13"></p><p><img src="/img/20190110/arch-14.jpeg" alt="bug14"></p><p><img src="/img/20190110/arch-15.jpeg" alt="bug15"></p><p><img src="/img/20190110/arch-16.jpeg" alt="bug16"></p><p><img src="/img/20190110/arch-17.jpeg" alt="bug17"></p><p><img src="/img/20190110/arch-18.jpeg" alt="bug18"></p><p><img src="/img/20190110/arch-19.jpeg" alt="bug19"></p><p><img src="/img/20190110/arch-20.jpeg" alt="bug20"></p><p><img src="/img/20190110/arch-21.jpeg" alt="bug21"></p><p><img src="/img/20190110/arch-22.jpeg" alt="bug22"></p><p><img src="/img/20190110/arch-23.jpeg" alt="bug23"></p><p><img src="/img/20190110/arch-24.jpeg" alt="bug24"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/img/20190110/1.png&quot; alt=&quot;bug1&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;线上运行的Java应用突然没有响应、响应缓慢，进程突然消失，遇到这些情况应该如何应对呢？&lt;/p&gt;
&lt;p&gt;来自公司内部分享&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="bug修复" scheme="http://yoursite.com/tags/bug%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>java分布式锁之redis实现篇</title>
    <link href="http://yoursite.com/2019/01/09/java%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/09/java分布式锁/</id>
    <published>2019-01-09T08:03:11.000Z</published>
    <updated>2019-01-11T02:36:32.319Z</updated>
    
    <content type="html"><![CDATA[<p><strong> &ensp;&ensp;&ensp;&ensp;刚开始写这篇文章的时候其实我是拒绝的，因为我也是最近才接触这方面的知识点，实现技术本身也是雕虫小技，但是我还是觉得拿出来与大家一起分享，本着一个学习的态度吧，如果有大佬看到，请指点一二哈！ </strong></p><p><img src="/img/头图.jpg" alt="头图"></p><hr><h1 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h1><p>&ensp;&ensp;&ensp;&ensp;由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，那么就要利用分布式锁来解决这些问题。所以将自己的心得体会记录下来做一个讲解和总结。希望这篇文章可以方便自己以后查阅，同时要是能帮助到刚开始接触到这方面的同学那也是很好的。</p><h1 id="2、为什么要使用分布式锁"><a href="#2、为什么要使用分布式锁" class="headerlink" title="2、为什么要使用分布式锁"></a>2、为什么要使用分布式锁</h1><p>&ensp;&ensp;&ensp;&ensp;关于分布式锁，可能绝大部分人都会或多或少涉及到。 我举二个例子：<br>场景一：从前端界面发起一笔支付请求，如果前端没有做防重处理，那么可能在某一个时刻会有二笔一样的单子同时到达系统后台。<br>场景二：在App中下订单的时候，点击确认之后，没反应，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。 在接收消息的时候，消息推送重复。如果处理消息的接口无法保证幂等，那么重复消费消息产生的影响可能会非常大。</p><p>&ensp;&ensp;&ensp;&ensp;为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><h1 id="3、分布式锁应该具备的条件"><a href="#3、分布式锁应该具备的条件" class="headerlink" title="3、分布式锁应该具备的条件"></a>3、分布式锁应该具备的条件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</span><br><span class="line">高可用的获取锁与释放锁；</span><br><span class="line">高性能的获取锁与释放锁；</span><br><span class="line">具备可重入特性；</span><br><span class="line">具备锁失效机制，防止死锁；</span><br><span class="line">具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</span><br></pre></td></tr></table></figure><h1 id="4、基于redis的实现方式"><a href="#4、基于redis的实现方式" class="headerlink" title="4、基于redis的实现方式"></a>4、基于redis的实现方式</h1><h2 id="4-1、选择redis实现分布式锁的原因"><a href="#4-1、选择redis实现分布式锁的原因" class="headerlink" title="4.1、选择redis实现分布式锁的原因"></a>4.1、选择redis实现分布式锁的原因</h2><ul><li>Redis有很高的性能</li><li>Redis命令对此支持较好，实现起来比较方便</li></ul><h2 id="4-2、使用命令介绍"><a href="#4-2、使用命令介绍" class="headerlink" title="4.2、使用命令介绍"></a>4.2、使用命令介绍</h2><p>（1）SETNX：SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</p><p>（2）expire：expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</p><p>（3）delete：delete key：删除key</p><p>在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。</p><h2 id="4-3、实现思想"><a href="#4-3、实现思想" class="headerlink" title="4.3、实现思想"></a>4.3、实现思想</h2><p>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><h2 id="4-4、具体实现流程"><a href="#4-4、具体实现流程" class="headerlink" title="4.4、具体实现流程"></a>4.4、具体实现流程</h2><p>关于redis分布式锁的实现流程如下图所示：</p><p><img src="/img/Redis分布式锁流程图.png" alt="redis分布式锁"></p><p>注意：单个线程任务处理时间threadTime、获取锁的等待时间acquireTimeout、锁的过期时间timeout三者之间的关系：</p><pre><code>1、threadTime &lt; timeout  （不然会出错）2、acquireTimeout &lt; threadTime &lt; timeout  (一般标准的设置时间方法)</code></pre><p>废话不多说，直接上代码：</p><p><strong> TestRedisLock类 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//redis分布式锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String indentifier = <span class="keyword">null</span>;</span><br><span class="line">        RedisLock redisLock = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//toDO 增加分布式锁逻辑</span></span><br><span class="line">            redisLock = <span class="keyword">new</span> RedisLock(RedisClient.jedisSentinelPool);</span><br><span class="line">            <span class="comment">//首次获取到锁是必然的  acquireTimeout 为获取锁的等待时间，如果超过此时间就放弃      timeout 为锁的过期时间</span></span><br><span class="line">            indentifier = redisLock.lockWithTimeout(<span class="string">"ss_test"</span>,<span class="number">3500</span>, <span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">"尝试获取锁,indentifier:"</span>+indentifier);</span><br><span class="line">            ThreadLocal&lt;AtomicInteger&gt; threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">            threadLocal.set(<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span> (indentifier == <span class="keyword">null</span>)&#123;<span class="comment">//一直请求锁，直到拿到为止</span></span><br><span class="line">                threadLocal.get().getAndIncrement();</span><br><span class="line">                indentifier = redisLock.lockWithTimeout(<span class="string">"ss_test"</span>,<span class="number">3500</span>, <span class="number">3000</span>);</span><br><span class="line">                <span class="comment">//Thread.currentThread().sleep(100);</span></span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"尝试获取锁,indentifier:"</span>+indentifier+<span class="string">"，第"</span>+threadLocal.get().get()+<span class="string">"次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(indentifier!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//拿到锁开始干活</span></span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"获取到锁,indentifier:"</span>+indentifier);</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">                <span class="comment">//System.out.println(1/0);</span></span><br><span class="line">                <span class="comment">//todo 执行任务</span></span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"执行完成"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"没有获取到锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(redisLock!=<span class="keyword">null</span> &amp;&amp; StringUtils.isNotEmpty(indentifier))&#123;</span><br><span class="line">                redisLock.releaseLock(<span class="string">"ss_test"</span>,indentifier);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//todo 线程锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟100人抢购</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        lock();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> RedisLock类 </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(RedisLock.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(JedisPool jedisPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedisPool = jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> locaName  锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeout  尝试获取锁超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout   key的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">lockWithTimeout</span><span class="params">(String locaName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">long</span> acquireTimeout, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        String retIdentifier = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取连接</span></span><br><span class="line">            <span class="comment">// 随机生成一个value</span></span><br><span class="line">            String identifier = UUID.randomUUID().toString();    <span class="comment">//如果identifier存在则成功获取到锁，否则表明该锁已经被其他线程占用</span></span><br><span class="line">            <span class="comment">// 锁名，即key值</span></span><br><span class="line">            String lockKey = <span class="string">"lock:"</span> + locaName;</span><br><span class="line">            <span class="comment">// 超时时间，上锁后超过此时间则自动释放锁</span></span><br><span class="line">            <span class="keyword">int</span> lockExpire = (<span class="keyword">int</span>)(timeout / <span class="number">1000</span>);</span><br><span class="line">            conn = jedisPool.getResource();</span><br><span class="line">            <span class="comment">// 获取锁的超时时间，超过这个时间则放弃获取锁</span></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis() + acquireTimeout;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; end) &#123;</span><br><span class="line">                <span class="comment">//Jedis conn = jedisPool.getResource();</span></span><br><span class="line">                <span class="comment">//System.out.println("等待时间:"+System.currentTimeMillis());</span></span><br><span class="line">                <span class="keyword">if</span> (conn.setnx(lockKey, identifier) == <span class="number">1</span>) &#123;</span><br><span class="line">                    conn.expire(lockKey, lockExpire);</span><br><span class="line">                    <span class="comment">// 返回value值，用于释放锁时间确认</span></span><br><span class="line">                    retIdentifier = identifier;</span><br><span class="line">                    <span class="comment">/*if (conn != null) &#123;</span></span><br><span class="line"><span class="comment">                        conn.close();</span></span><br><span class="line"><span class="comment">                        //System.out.println("关闭连接");</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                    <span class="keyword">return</span> retIdentifier;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回-1代表key没有设置超时时间，为key设置一个超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (conn.ttl(lockKey) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    conn.expire(lockKey, lockExpire);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    logger.error(<span class="string">"RedisLock中断异常"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">             <span class="comment">/*   if (conn != null) &#123;</span></span><br><span class="line"><span class="comment">                    conn.close();</span></span><br><span class="line"><span class="comment">                    //System.out.println("关闭连接");</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"RedisLock获取锁异常"</span>,e);</span><br><span class="line">            <span class="comment">//jedisPool.returnBrokenResource(conn);</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">               <span class="comment">// System.out.println("关闭连接");</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifier    释放锁的标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockName, String identifier)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        String lockKey = <span class="string">"lock:"</span> + lockName;</span><br><span class="line">        <span class="keyword">boolean</span> retFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 监视lock，准备开始事务</span></span><br><span class="line">                conn.watch(lockKey);</span><br><span class="line">                <span class="comment">// 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁</span></span><br><span class="line">                <span class="keyword">if</span> (identifier.equals(conn.get(lockKey))) &#123;</span><br><span class="line">                    Transaction transaction = conn.multi();</span><br><span class="line">                    transaction.del(lockKey);</span><br><span class="line">                    List&lt;Object&gt; results = transaction.exec();</span><br><span class="line">                    <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    retFlag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn.unwatch();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"RedisLock释放锁异常"</span>,e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次测试模拟五个线程，acquireTimeout = 2500， threadTime = 2700 ， timeout = 3000</p><p>实验结果如下：</p><p><img src="/img/redis分布式锁测试结果.png" alt="redis分布式实验结果"></p><h1 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h1><p>&ensp;&ensp;&ensp;&ensp;在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。 当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;刚开始写这篇文章的时候其实我是拒绝的，因为我也是最近才接触这方面的知识点，实现技术本身也是雕虫小技，但是我还是觉得拿出来与大家一起分享，本着一个学习的态度吧，如果有大佬看到，请指点一二哈！ &lt;/strong&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【深度好文】simhash文本去重流程</title>
    <link href="http://yoursite.com/2019/01/06/simhash/"/>
    <id>http://yoursite.com/2019/01/06/simhash/</id>
    <published>2019-01-06T12:37:41.000Z</published>
    <updated>2019-01-16T03:58:40.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong> &ensp;&ensp;&ensp;&ensp;本人目前就职于某厂新闻客户端，对于新闻客户端而言，推荐的每一刷的新闻都必须是不同的新闻，这就需要对新闻文本进行排重。传统的去重一般是对文章的url链接进行排重，但是对于抓取的网页来说，各大平台的新闻可能存在重复，对于只通过文章url进行排重是不靠谱的，为了解决这个痛点于是就提出了用simhash来解决这个难题。 </strong></p><hr><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>&ensp;&ensp;&ensp;&ensp;传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。即便是两个原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统的Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种<a href="https://www.cnblogs.com/maybe2030/p/4953039.html" target="_blank" rel="noopener">局部敏感hash</a>，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过算出两个指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低（根据 Detecting Near-Duplicates for Web Crawling 论文中所说），一般海明距离为3就代表两篇文章相同。<br>&ensp;&ensp;&ensp;&ensp;<a href="http://www.wwwconference.org/www2007/papers/paper215.pdf" target="_blank" rel="noopener">simhash</a>也有其局限性，在处理小于500字的短文本时，simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。</p><h1 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h1><p><strong> 如何设计一个比较两篇文章相似度的算法？可能你会回答几个比较传统点的思路: </strong></p><ul><li>一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离（可以计算它们之间的<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%BA%A6%E9%87%8F/1274107?fr=aladdin" target="_blank" rel="noopener">欧氏距离</a>、<a href="https://baike.baidu.com/item/%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB" target="_blank" rel="noopener">海明距离</a>或者<a href="https://baike.baidu.com/item/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6" target="_blank" rel="noopener">夹角余弦</a>等等），从而通过距离的大小来判断两篇文章的相似度。</li><li>另外一种是传统hash，我们考虑为每一个web文档通过hash的方式生成一个指纹（finger print）。</li></ul><p><strong> 下面我们来分析一下这两种方法: </strong></p><ul><li>采取第一种方法，若是只比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度。你还会去计算任意两个网页之间的距离或夹角余弦么？那样做的话时间复杂度，空间复杂度可想而知。</li><li>而第二种方案中所说的传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化。</li></ul><h1 id="3-simhash与hash算法的区别"><a href="#3-simhash与hash算法的区别" class="headerlink" title="3.simhash与hash算法的区别"></a>3.simhash与hash算法的区别</h1><p>&ensp;&ensp;&ensp;&ensp;传统Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统hash算法产生的两个签名，如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大，所以传统Hash是无法在签名的维度上来衡量原内容的相似度。而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。<br>&ensp;&ensp;&ensp;&ensp;我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里，估计大家就明白了，即使把文章中的字符串变成 01 串，我们使用的simhash算法也还是可以用于计算相似度，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。</p><h1 id="4-simhash原理"><a href="#4-simhash原理" class="headerlink" title="4.simhash原理"></a>4.simhash原理</h1><blockquote><p>simhash是google用来处理海量文本去重的算法。 google出品，你懂的。 simhash最牛逼的一点就是将一个文档，最后转换成一个64位的字节，暂且称之为特征字，然后判断重复只需要判断他们的特征字的距离是不是&lt;n（根据经验这个n一般取值为3），就可以判断两个文档是否相似。</p></blockquote><p><strong> 算法过程大致如下：</strong></p><ul><li>1，对文本分词，得到N维特征向量（默认为64维）</li><li>2，为分词设置权重（tf-idf）</li><li>3，为特征向量计算哈希</li><li>4，对所有特征向量加权，累加（目前仅进行非加权累加）</li><li>5，对累加结果，大于零置一，小于零置零</li><li>6，得到文本指纹（fingerprint）</li></ul><p><strong> 具体流程实现 </strong></p><p>simhash的算法具体分为5个步骤：<strong>分词</strong>、<strong>hash</strong>、<strong>加权</strong>、<strong>合并</strong>、<strong>降维</strong>，具体过程如下：</p><ul><li><p>分词</p><ul><li>给定一段语句或者一段文本，进行分词，得到有效的特征向量，然后为每一个特征向量设置一个5个级别（1—5）权值。例如给定一段语句：“生活本没有路，走的人多了就成了路，要相信阳光总在风雨后”，分词后结果为：生活 没有 成了 相信 阳光 风雨，然后为每个特征向量赋予权值：<br>生活(5) 没有(2) 成了(1) 相信(2) 阳光(3) 风雨(2)，其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。</li></ul></li><li><p>hash</p><ul><li>通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“生活”的hash值Hash(生活)为110101，“没有”的hash值Hash(没有)为“101001”。就这样，字符串就变成了一系列数字。</li></ul></li><li><p>加权</p><ul><li>在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘。例如给“生活”的hash值“110101”加权得到：W(生活) = 110101 5 = 5 5 -5 5 -5 5，给“没有”的hash值“101001”加权得到：W(没有)=101001 2 = 2 -2 2 -2 -2 2，其余特征向量类似此般操作。</li></ul></li><li><p>合并</p><ul><li>将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“生活”的“5 5 -5 5 -5 5”和“没有”的“2 -2 2 -2 -2 2”进行累加，得到“5+2 5-2 -5+2 5-2 -5-2 5+2”，得到“7 3 -3 3 -7 7”。</li></ul></li><li><p>降维</p><ul><li>对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 1 0 1 0 1”，从而形成它们的simhash签名。</li></ul></li></ul><p>整个过程的流程图为：</p><p><img src="/img/simhash/simhash1.jpeg" alt="simhash1"></p><h1 id="5、simhash的签名距离计算"><a href="#5、simhash的签名距离计算" class="headerlink" title="5、simhash的签名距离计算"></a>5、simhash的签名距离计算</h1><p>&ensp;&ensp;&ensp;&ensp;我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： 10101 和 00110 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。</p><p>&ensp;&ensp;&ensp;&ensp;我们可以把 64 位的二进制simhash签名均分成4块，每块16位。根据鸽巢原理（也称抽屉原理），如果两个签名的海明距离在 3 以内，它们必有一块完全相同。如下图所示：<br><img src="/img/simhash/simhash2.jpeg" alt="simhash2"></p><h1 id="6、simhash的存储和查找"><a href="#6、simhash的存储和查找" class="headerlink" title="6、simhash的存储和查找"></a>6、simhash的存储和查找</h1><ol><li>我们需要将64位simhash均分为4份，然后每份作为key存储到redis</li><li>采用精确匹配的方式查找前16位</li><li>找到则拿出来计算与被比较的simahsh距离，小于3则判断为相似（当然具体问题具体分析，这个值可以调整）</li><li>如果样本库中存有2^34（差不多10亿）的哈希指纹，则每个table返回2^(34-16)=262144个候选结果，大大减少了海明距离的计算成本 </li></ol><p><img src="/img/simhash/simhash3.jpeg" alt="simhash3"></p><h1 id="7、聊聊Jaccard相似度与汉明距离"><a href="#7、聊聊Jaccard相似度与汉明距离" class="headerlink" title="7、聊聊Jaccard相似度与汉明距离"></a>7、聊聊Jaccard相似度与汉明距离</h1><h2 id="7-1-Jaccard相似度"><a href="#7-1-Jaccard相似度" class="headerlink" title="7.1 Jaccard相似度"></a>7.1 Jaccard相似度</h2><p>&ensp;&ensp;&ensp;&ensp; Jaccard 系数，又叫Jaccard相似性系数，用来比较样本集中的相似性和分散性的一个概率。<br>公式：</p><p><img src="/img/simhash/jaccard.png" alt="jaccard"></p><p>给定两个集合A,B jaccard 系数定义为A与B交集的大小与并集大小的比值，jaccard值越大说明相似度越高</p><h2 id="7-2-汉明距离"><a href="#7-2-汉明距离" class="headerlink" title="7.2 汉明距离"></a>7.2 汉明距离</h2><p>&ensp;&ensp;&ensp;&ensp;在信息理论中，Hamming Distance 表示两个等长字符串在对应位置上不同字符的数目，我们以d(x, y)表示字符串x和y之间的汉明距离。从另外一个方面看，汉明距离度量了通过替换字符的方式将字符串x变成y所需要的最小的替换次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">举例说明以下字符串间的汉明距离为：</span><br><span class="line">&quot;karolin&quot; and &quot;kathrin&quot; is 3.</span><br><span class="line">&quot;karolin&quot; and &quot;kerstin&quot; is 3.</span><br><span class="line">1011101 and 1001001 is 2.</span><br><span class="line">2173896 and 2233796 is 3.</span><br></pre></td></tr></table></figure><h1 id="8、【实战】新闻文本去重服务详细流程"><a href="#8、【实战】新闻文本去重服务详细流程" class="headerlink" title="8、【实战】新闻文本去重服务详细流程"></a>8、【实战】新闻文本去重服务详细流程</h1><p>&ensp;&ensp;&ensp;&ensp;上面陆陆续续讲了这么多理论知识想必大家也是一头雾水，接下来我们通过实战来讲述整体流程。</p><p><img src="/img/simhash/pic1.gif" alt="pic1"></p><p>&ensp;&ensp;&ensp;&ensp;本文将文本排重做成了一个接口，首先给去重接口传一些必要的参数，针对新闻文本为例（url:链接 title:文本标题 content:内容）。依次是进行url排重、title排重、content排重，<br>如果三种都没有找到，则建立url、title、content索引存储到redis。具体流程图如下：</p><p><img src="/img/simhash/SIMHASH.png" alt="simhash4"></p><h2 id="8-1、URL排重"><a href="#8-1、URL排重" class="headerlink" title="8.1、URL排重"></a>8.1、URL排重</h2><ol><li><p>建立URL索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key: url_index_name+&quot;_&quot;+urlMD5。url_index_name为索引名字，urlMD5表示url的MD5值</span><br><span class="line">value: docId+&quot;\t&quot;+url+&quot;\t&quot;+storageTime。  docId为新闻的事件id，url表示新闻链接，storageTime表示存入redis的时间戳</span><br></pre></td></tr></table></figure></li><li><p>根据urlMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。</p></li></ol><h2 id="8-2、Title排重"><a href="#8-2、Title排重" class="headerlink" title="8.2、Title排重"></a>8.2、Title排重</h2><ol><li><p>建立Title索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key: title_index_name+&quot;_&quot;+titleMD5。title_index_name为索引名字，titleMD5表示title的MD5值</span><br><span class="line">value: docId+&quot;\t&quot;+title+&quot;\t&quot;+url+&quot;\t&quot;+storageTime。  docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳</span><br></pre></td></tr></table></figure></li><li><p>根据titleMD5从redis查找数据，找到则排重成功返回docId，没有找到则排重失败。</p></li></ol><h2 id="8-3、Content排重"><a href="#8-3、Content排重" class="headerlink" title="8.3、Content排重"></a>8.3、Content排重</h2><ol><li><p>建立Content索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先将64位simhash值均分为4份：</span><br><span class="line">simHashFragment1、simHashFragment2、simHashFragment3、simHashFragment4</span><br><span class="line">key: content_index_name+&quot;_&quot;+simHashFragment。content_index_name为索引名字，simHashFragment表示其中一段simhash值（16位）</span><br><span class="line">value: docId+&quot;\t&quot;+title+&quot;\t&quot;+simhash+&quot;\t&quot;+url+&quot;\t&quot;+storageTime。  docId为新闻的事件id，title为新闻标题，url表示新闻链接，storageTime表示存入redis的时间戳</span><br></pre></td></tr></table></figure></li><li><p>然后将这4份索引存储到redis(LIST)</p></li><li>根据simHashFragment索引从redis里面查找（4份simhash索引都得一起召回）</li><li>将召回的值依次与带排重的文本比对<ul><li>hanmingDistance&lt;=H 并且 jarccardSimilary&gt;=J 召回(一般设置H=10,J=0.7 具体情况具体分析)  注：三天内新闻做法</li><li>hanmingDistance&lt;=3 并且 jarccardSimilary&gt;=0.7  注：三天外新闻做法</li></ul></li><li>将召回的新闻做rank（这里不细讲，方法很多），TOP1作为排重的新闻</li></ol><h1 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h1><p>&ensp;&ensp;&ensp;&ensp;现如今是一个信息过载的时代，高效的从海量文本里面快速找到相似的文本是一个需要解决的一个痛点，simhash的存在就很好的解决了这个问题。</p><p>&ensp;&ensp;&ensp;&ensp;由于simhash是局部敏感的hash，其可能不适合做这种短标题的重复度判断，会存在一定的误差，文本越长判断的准确率越高。</p><hr><p>好记性不如烂笔头，记录点滴！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;本人目前就职于某厂新闻客户端，对于新闻客户端而言，推荐的每一刷的新闻都必须是不同的新闻，这就需要对新闻文本进行排重。传统的去重一般是对文章的url链接进行排重，但是对于抓取的网页来说，各大平台的新闻可能存在重
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="文本去重" scheme="http://yoursite.com/tags/%E6%96%87%E6%9C%AC%E5%8E%BB%E9%87%8D/"/>
    
      <category term="simhash" scheme="http://yoursite.com/tags/simhash/"/>
    
  </entry>
  
  <entry>
    <title>markdown基本语法</title>
    <link href="http://yoursite.com/2019/01/05/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/05/markdown基本语法/</id>
    <published>2019-01-05T13:31:07.000Z</published>
    <updated>2019-01-08T10:05:38.100Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp; markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><ul><li>优点<ul><li>因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</li><li>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而markdown只需要在标题内容前加#即可</li></ul></li><li>缺点<ul><li>需要记一些语法（当然，是很简单。五分钟学会）。</li><li>有些平台不支持markdown编辑模式。</li></ul></li></ul><hr><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>&ensp;&ensp;&ensp;&ensp; 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><hr><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li>加粗</li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li>斜体</li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li>斜体加粗</li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li>删除线</li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><hr><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><hr><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><hr><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure></p><hr><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[搜狐](http://www.souhu.com)</span><br><span class="line">[百度](http://www.baidu.com)</span><br></pre></td></tr></table></figure></p><hr><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：<br>无序列表用 - + * 任何一种都可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure></p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：<br>数字加点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure></p><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>上一级和下一级之间敲三个空格即可</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ol><li>二级有序列表内容</li></ol></li></ol><hr><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 水果 | 价格 | 数量 | </span><br><span class="line">| -------- | -----: | :----: | </span><br><span class="line">| 香蕉 | $1 | 5 | </span><br><span class="line">| 苹果 | $1 | 6 | </span><br><span class="line">| 草莓 | $1 | 7 |</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>水果</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>香蕉</td><td style="text-align:right">$1</td><td style="text-align:center">5</td></tr><tr><td>苹果</td><td style="text-align:right">$1</td><td style="text-align:center">6</td></tr><tr><td>草莓</td><td style="text-align:right">$1</td><td style="text-align:center">7</td></tr></tbody></table><hr><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br>单行代码：代码之间分别用一个反引号包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure></p><p>python 代码块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = range(<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">   <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">   print(i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>java 代码块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> URLInfo <span class="title">extractURLHost</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">URLInfo urlInfo = <span class="keyword">new</span> URLInfo();</span><br><span class="line">String host = HostDomainExtractKit.extractURLHost(url);</span><br><span class="line">String domain = HostDomainExtractKit.getTopLevelDomain(url);</span><br><span class="line">urlInfo.setHost(host);</span><br><span class="line">urlInfo.setDomain(domain);</span><br><span class="line"><span class="keyword">return</span> urlInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><p>一般写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;End</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></p><p><img src="/img/流程图.png" alt="流程图"></p><p><strong><em>注：MarkDown没 有统一标准，不同网站实现的方式不同，目前github上写markdown，并没有实现流程图的语法。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp; markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;因为是纯文本，所以只要支持markdown的地方都能获得一样的编辑效果，可
      
    
    </summary>
    
      <category term="markdown" scheme="http://yoursite.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下安装PyV8</title>
    <link href="http://yoursite.com/2019/01/03/pyv8/"/>
    <id>http://yoursite.com/2019/01/03/pyv8/</id>
    <published>2019-01-03T15:42:15.000Z</published>
    <updated>2019-01-08T10:05:38.093Z</updated>
    
    <content type="html"><![CDATA[<p>这几天需要使用PyV8来进行python与javascript的交互，在ubuntu上面安装遇到了不少的坑，折腾几小时终于找到方法。</p><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install scons</span><br><span class="line">$ sudo apt-get install libboost-dev libboost-thread-dev</span><br><span class="line">$ sudo apt-get install libboost-system-dev libboost-python-dev</span><br></pre></td></tr></table></figure><h1 id="安装Pyv8"><a href="#安装Pyv8" class="headerlink" title="安装Pyv8"></a>安装Pyv8</h1><p>&ensp;&ensp;&ensp;&ensp;下载二进制文件<a href="https://github.com/emmetio/pyv8-binaries" target="_blank" rel="noopener">github</a>找到适合你机器的版本下载。解压出来应该有两个文件：<em>PyV8.py</em> ,<em> _PyV8.so</em>,然后把这两个文件拷贝到你的python第三方包的目录里面就好，比如我的是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> pyv8</span><br><span class="line">$ sudo cp * /usr/lib/python2.7/dist-packages/</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;然后进入到python环境测试如下代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import PyV8</span><br><span class="line">ctxt = PyV8.JSContext()</span><br><span class="line">ctxt.enter()</span><br><span class="line">func = ctxt.eval(<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">(function()&#123;</span></span><br><span class="line"><span class="string">    function hello()&#123;</span></span><br><span class="line"><span class="string">        return "</span>Hello world.<span class="string">";</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return hello();</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>)</span><br><span class="line"><span class="built_in">print</span> func()</span><br></pre></td></tr></table></figure></p><p>执行输出Hello World说明安装成功了，就可以模拟JS代码了。</p><hr><p>好记性不如烂笔头，记录点滴！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天需要使用PyV8来进行python与javascript的交互，在ubuntu上面安装遇到了不少的坑，折腾几小时终于找到方法。&lt;/p&gt;
&lt;h1 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="pyv8" scheme="http://yoursite.com/tags/pyv8/"/>
    
  </entry>
  
  <entry>
    <title>hexo一个错误解</title>
    <link href="http://yoursite.com/2019/01/02/error/"/>
    <id>http://yoursite.com/2019/01/02/error/</id>
    <published>2019-01-02T15:42:15.000Z</published>
    <updated>2019-01-08T10:05:38.107Z</updated>
    
    <content type="html"><![CDATA[<p>今天进入到博客目录，发现hexo命令行用不了了，报如下错误：</p><blockquote><p>ERROR Local hexo not found in ~/Downloads/hexo/blog</p></blockquote><blockquote><p>ERROR Try running: ‘npm install hexo –save’</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>rm -rf node_modules</p></blockquote><blockquote><p>npm install</p></blockquote><p>ok,至此hexo命令已经可以运行，问题解决！</p><hr><p><strong>好记性不如烂笔头，记录点滴！</strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天进入到博客目录，发现hexo命令行用不了了，报如下错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ERROR Local hexo not found in ~/Downloads/hexo/blog&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="常见错误解决" scheme="http://yoursite.com/categories/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>smilemilk的第一次博客之旅</title>
    <link href="http://yoursite.com/2019/01/01/hello-world/"/>
    <id>http://yoursite.com/2019/01/01/hello-world/</id>
    <published>2019-01-01T01:42:15.000Z</published>
    <updated>2019-01-10T08:56:06.019Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我将会和大家在接下来的日子里面一起分享自己的<strong>爬虫</strong>+<strong>搜索</strong>+<strong>大数据</strong>方面的工程经验，</p><p>&ensp;&ensp;&ensp;&ensp;本来2018年就想写点自己的东西一直拖到2019年（🤦捂脸。。。♀)，主要是因为2018年整个在忙实习还有硕士毕业的各种事情。转眼就到 2019 年了，其实我没有写总结的习惯，现在到头来还是蛮后悔的，说实话总结其实还是蛮有必要的，现在就趁着这个时间来立一下 2019 的 Flag，再等到 2020 年翻出来打脸吧，哈哈😄。</p><blockquote><p>35岁之前只做能提高自己技术水平的事情，能够成为公认的某一个技术领域的专家。<br>不随波逐流，要独树一帜。</p></blockquote><p><img src="/img/simhash/pic1.gif" alt="pic1"></p><hr><p>优质博客：</p><p><a href="http://www.zsythink.net/" target="_blank" rel="noopener">zsythink</a></p><p><a href="https://cuiqingcai.com/" target="_blank" rel="noopener">崔庆才</a></p><p><a href="http://www.rowkey.me/" target="_blank" rel="noopener">rowkey</a></p><p><a href="https://blog.csdn.net/xlgen157387?t=1" target="_blank" rel="noopener">徐刘根</a></p><p><strong>好记性不如烂笔头，接下来我的博客将会陆续更新，博客还在施工中，敬请期待！！</strong>        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这里我将会和大家在接下来的日子里面一起分享自己的&lt;strong&gt;爬虫&lt;/strong&gt;+&lt;strong&gt;搜索&lt;/strong&gt;+&lt;strong&gt;大数据&lt;/strong&gt;方面的工程经验，&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;本来2018年就想写点自
      
    
    </summary>
    
      <category term="about me" scheme="http://yoursite.com/categories/about-me/"/>
    
    
  </entry>
  
</feed>
